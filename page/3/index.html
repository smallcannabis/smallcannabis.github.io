<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Welcome to smallcracker&#39;s personal website</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Welcome to smallcracker&#39;s personal website">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Welcome to smallcracker&#39;s personal website">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="smallcracker">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Welcome to smallcracker's personal website" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Welcome to smallcracker&#39;s personal website</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">联系方式：1426090870</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Analog Comparator（待完成）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/30/Analog%20Comparator%EF%BC%88%E5%BE%85%E5%AE%8C%E6%88%90%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2021-01-29T16:00:00.000Z" itemprop="datePublished">2021-01-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/30/Analog%20Comparator%EF%BC%88%E5%BE%85%E5%AE%8C%E6%88%90%EF%BC%89/">Analog Comparator</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Analog-Comparator"><a href="#Analog-Comparator" class="headerlink" title="Analog Comparator"></a>Analog Comparator</h1><h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>模拟比较器可以将一个测试电压和一个独立的外部参考电压，共用的外部参考电压或共用的内部参考电压进行比较。它可以把比较结果输出到引脚上，也可以用于触发中断、触发ADC采样。它的中断产生逻辑是独立于ADC触发逻辑的，所以，AC可以基于一个事件产生一个中断，ADC可以基于另一个事件产生触发。比如说，让上升沿触发一次中断，让下降沿触发一次ADC。</p>
<p>该芯片提供了两个独立的模拟比较器。</p>
<p><img src="image-20210130173507102.png" alt="照片"><br><img src="image-20210130173536884.png" alt="image-20210130173536884"><br>原理演示图<br><img src="image-20210130173642377.png" alt="image-20210130173642377"><br>它的头文件是driverlib/comp.h</p>
<h3 id="二、函数介绍"><a href="#二、函数介绍" class="headerlink" title="二、函数介绍"></a>二、函数介绍</h3><p><img src="image-20210130100105290.png" alt="image-20210130100105290"></p>
<ol>
<li><code>ComparatorConfigure()</code> 用来配置一个AC模块触发ADC模块的条件、触发中断的条件、和谁比较、正常输出还是反转输出</li>
<li><code>ComparatorIntClear()</code> 用于清除比较器中断标志，<em>（ 小贴士，因为在Contex-M处理器中写入有缓冲，所以执行函数之后过几个周期中断源才可能真正被清除，所以我们推荐在中断函数的一开始就清除中断标识）</em></li>
<li><code>ComparatorIntDisable()</code> 失能一个比较器中断</li>
<li><code>ComparatorIntEnable()</code> 使能一个比较器中断</li>
<li><code>ComparatorIntRegister()</code> 注册中断函数</li>
<li><code>ComparatorIntStatus()</code> 获取当前中断状态</li>
<li><code>ComparatorIntUnregister()</code> 注销一个中断函数</li>
<li><code>ComparatorRefSet()</code> 设定内部参考电压</li>
<li><code>ComparatorValueGet()</code> 获取当前比较器输出值，<strong>true</strong>表示比较器输出是高，<strong>false</strong>表示比较器输出是低</li>
</ol>
<ul>
<li>此外还需要用到一些GPIO函数来实现比较器功能<ol>
<li><code>GPIOPinTypeComparator()</code> 配置引脚用于模拟比较器输入</li>
<li><code>GPIOPinTypeComparatorOutput()</code> 配置引脚作为模拟比较器输出</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/30/Analog%20Comparator%EF%BC%88%E5%BE%85%E5%AE%8C%E6%88%90%EF%BC%89/" data-id="cko4hr64e000krw0k6gku32ot" data-title="Analog Comparator" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-FPU" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/30/FPU/" class="article-date">
  <time class="dt-published" datetime="2021-01-29T16:00:00.000Z" itemprop="datePublished">2021-01-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/30/FPU/">FPU</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="FPU"><a href="#FPU" class="headerlink" title="FPU"></a>FPU</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FPU指的是浮点运算单元。默认情况下，我们不能使用浮点数，只有使能了FPU才能浮点数。如果不打开浮点运算单元就用浮点数的话，单片机就会产生一个NOCP错误。（RTOS可以利用这个特性判断哪一项任务使用了浮点运算单元，以此只在涉及到这些任务的task switch中执行FPU。）</p>
<p>当处理器执行一条中断命令时，有三种办法处理浮点运算内容：1.不去算 2.总是存下来浮点运算内容 3.对浮点运算内容执行一个 lazy save/restore 。</p>
<p>如果不去算的话，中断栈帧就和没有浮点运算单元的Cortex-M 处理器的就一样了。（当那些主程序用到浮点运算，中断函数不用浮点运算时，这种方法会特别好用）(没看出来)（我们像这样不存储浮点运算内容的话，就能减少对栈的使用，降低中断延迟）</p>
<p>除此以外，我们还能把浮点运算内容存储总是到栈里面。这种方法允许在中断函数里面使用浮点运算，代价是栈的使用会增加，中断延迟会增加（因为我们还要向栈里面多写一些东西）。这种方法还有一个优点，那就是在中断函数的栈帧内一直存着浮点运算单元。</p>
<p>对浮点运算内容的默认处理是执行一个lazy save/restore。当我们开始一个中断时，在栈里面我们为浮点运算内容预留出一部分空间（留着一会往里面写内容）。这种方法能降低中断的延迟，因为一会我们就只用去声明整数了。然后如果要执行一个浮点运算的话，我们就把浮点运算内容写到这个浮点运算指令前面。最终，当从中断返回的时候，浮点运算内容就会留在栈里面，直到它被复写。这种方法既保证了中断的快速反应，用能让我们在中断函数 里面使用浮点运算指令。</p>
<p>FPU在异常出现时会产生一个中断（比如说向下、向上溢出、除以零、无效操作，非法输入等情况下）。我们可以利用这些中断搞事情。</p>
<p>FPU也是可以被改造的。我们可以改造半精度浮点数值得格式，对无穷大数的处理，清零模式（这会牺牲完整的IEEE规范来提升速度）以及结果的循环模式。</p>
<p>头文件是driverlib/fpu.h</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/30/FPU/" data-id="cko4hr64k000wrw0kclkqbd9b" data-title="FPU" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-创建项目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T17:46:40.996Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<p>title：怎样新建一个项目<br>date：2021-1-29</p>
<h2 id="tag：单片机"><a href="#tag：单片机" class="headerlink" title="tag：单片机"></a>tag：单片机</h2><h1 id="怎样新建一个项目"><a href="#怎样新建一个项目" class="headerlink" title="怎样新建一个项目"></a>怎样新建一个项目</h1><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><ul>
<li>file- new ccs project</li>
<li>target里选择c系列</li>
<li>后面选择对应的单片机</li>
<li>connection里面选择stellaris</li>
<li>name里面起一个名字</li>
<li>下面选择with main.c</li>
</ul>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><ul>
<li><p>设置工程</p>
</li>
<li><p>打开projects 的properties</p>
</li>
<li><p>打开build的arm compiler 的include options 添加ti中的Tiva ware c这个文件夹</p>
</li>
<li><p>还有arm linker 的file search path的上面的那个框 其中要添加Tiva ware c这个文件夹中的driverlib的ccs 的debug的driverlib.lib</p>
</li>
</ul>
<p>这样就配置完成了，可以开始写代码了</p>
<hr>
<h2 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_memmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_ints.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_memmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_pwm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/fpu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/pin_map.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/rom.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/rom_map.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/sysctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utils/uartstdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/pwm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureUART</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);</span><br><span class="line">    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);</span><br><span class="line">    ROM_GPIOPinConfigure(GPIO_PA0_U0RX);</span><br><span class="line">    ROM_GPIOPinConfigure(GPIO_PA1_U0TX);</span><br><span class="line">    ROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);</span><br><span class="line">    UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);</span><br><span class="line">    UARTStdioConfig(<span class="number">0</span>, <span class="number">115200</span>, <span class="number">16000000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> clock;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    FPULazyStackingEnable();</span><br><span class="line">    <span class="comment">//使能系统时钟为50MHz</span></span><br><span class="line">    SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN);</span><br><span class="line">    <span class="comment">//延时函数</span></span><br><span class="line">    clock=SysCtlClockGet();</span><br><span class="line">    ROM_SysCtlDelay ( clock *ms / <span class="number">3000</span>);</span><br><span class="line">    ConfigureUART();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/" data-id="cko4hr65a0028rw0k8ralazsm" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-001-创建项目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/001-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/001-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/">怎样新建一个项目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="怎样新建一个项目"><a href="#怎样新建一个项目" class="headerlink" title="怎样新建一个项目"></a>怎样新建一个项目</h1><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><ul>
<li>file- new ccs project</li>
<li>target里选择c系列</li>
<li>后面选择对应的单片机</li>
<li>connection里面选择stellaris</li>
<li>name里面起一个名字</li>
<li>下面选择with main.c</li>
</ul>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><ul>
<li><p>设置工程</p>
</li>
<li><p>打开projects 的properties</p>
</li>
<li><p>打开build的arm compiler 的include options 添加ti中的Tiva ware c这个文件夹</p>
</li>
<li><p>还有arm linker 的file search path的上面的那个框 其中要添加Tiva ware c这个文件夹中的driverlib的ccs 的debug的driverlib.lib</p>
</li>
</ul>
<p>这样就配置完成了，可以开始写代码了</p>
<hr>
<h2 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_memmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_ints.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_memmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_pwm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/fpu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/pin_map.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/rom.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/rom_map.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/sysctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utils/uartstdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/pwm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> delay(ms) ROM_SysCtlDelay(clock*ms/3000)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> clock;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureUART</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prt_f</span><span class="params">(<span class="keyword">float</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        UARTprintf(<span class="string">&quot;%d.&quot;</span>,(<span class="keyword">int</span>)w);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        UARTprintf(<span class="string">&quot;0.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tem=(<span class="keyword">int</span>)(w*<span class="number">10000000</span>)%<span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">if</span>(tem&lt;<span class="number">1000000</span>)UARTprintf(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(tem&lt;<span class="number">100000</span>)UARTprintf(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(tem&lt;<span class="number">10000</span>)UARTprintf(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(tem&lt;<span class="number">1000</span>)UARTprintf(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(tem&lt;<span class="number">100</span>)UARTprintf(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(tem&lt;<span class="number">10</span>)UARTprintf(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(tem&lt;<span class="number">1</span>)UARTprintf(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    UARTprintf(<span class="string">&quot;%d&quot;</span>,tem);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> detection_queue[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> detection_index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> state=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> duration[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> message_index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tick=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> threshold=<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WTimer1AIntHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ulstatus = TimerIntStatus(WTIMER1_BASE,TIMER_TIMA_TIMEOUT);</span><br><span class="line">    TimerIntClear(WTIMER1_BASE, ulstatus);</span><br><span class="line">    <span class="keyword">int</span> ReadPin1 = GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4);<span class="comment">//检测</span></span><br><span class="line">    <span class="keyword">int</span> flag=((ReadPin1&amp;GPIO_PIN_4) != GPIO_PIN_4);</span><br><span class="line">    detection_queue[detection_index]=flag;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=threshold;i++)sum+=(<span class="keyword">int</span>)detection_queue[detection_index-i];</span><br><span class="line">    <span class="keyword">if</span>(tick&gt;threshold)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum==threshold&amp;&amp;state==<span class="literal">false</span>)&#123;</span><br><span class="line">            state=<span class="literal">true</span>;</span><br><span class="line">            duration[message_index]=tick;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>&amp;&amp;state==<span class="literal">true</span>)&#123;</span><br><span class="line">            state=<span class="literal">false</span>;</span><br><span class="line">            duration[message_index]=tick-duration[message_index];</span><br><span class="line">            UARTprintf(<span class="string">&quot;bottom up. message index is %d\nduration:%d\n&quot;</span>,message_index,duration[message_index]);</span><br><span class="line">            message_index++;</span><br><span class="line">            message_index%=<span class="number">110</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tick++;</span><br><span class="line">    detection_index++;</span><br><span class="line">    detection_index%=<span class="number">110</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Configurebottom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line">    GPIODirModeSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_DIR_MODE_IN);</span><br><span class="line">    GPIOPadConfigSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);</span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_WTIMER1);</span><br><span class="line">    TimerConfigure(WTIMER1_BASE,TIMER_CFG_PERIODIC);</span><br><span class="line">    TimerLoadSet64(WTIMER1_BASE, clock/<span class="number">500</span>);</span><br><span class="line">    TimerIntRegister(WTIMER1_BASE, TIMER_A, WTimer1AIntHandler);</span><br><span class="line">    IntMasterEnable();</span><br><span class="line">    TimerIntEnable(WTIMER1_BASE, TIMER_TIMA_TIMEOUT);</span><br><span class="line">    IntEnable(INT_WTIMER1A);</span><br><span class="line">    TimerEnable(WTIMER1_BASE, TIMER_A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureEverything</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FPUEnable();</span><br><span class="line">    FPULazyStackingEnable();</span><br><span class="line">    SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN);</span><br><span class="line">    clock=SysCtlClockGet();</span><br><span class="line">    ConfigureUART();</span><br><span class="line">    Configurebottom();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConfigureEverything();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureUART</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);</span><br><span class="line">    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);</span><br><span class="line">    ROM_GPIOPinConfigure(GPIO_PA0_U0RX);</span><br><span class="line">    ROM_GPIOPinConfigure(GPIO_PA1_U0TX);</span><br><span class="line">    ROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);</span><br><span class="line">    UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);</span><br><span class="line">    UARTStdioConfig(<span class="number">0</span>, <span class="number">115200</span>, <span class="number">16000000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/001-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/" data-id="cko4hr6410003rw0kf5lkf5qj" data-title="怎样新建一个项目" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ADC interrupt" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/ADC%20interrupt/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/ADC%20interrupt/">ADC中断</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ADC中断"><a href="#ADC中断" class="headerlink" title="ADC中断"></a>ADC中断</h1><h3 id="一、相关函数介绍"><a href="#一、相关函数介绍" class="headerlink" title="一、相关函数介绍"></a>一、相关函数介绍</h3><ol>
<li><code>ADCIntRegister()</code> 和<code>ADCIntUnregister()</code>用于为ADC中断注册（注销）一个中断函数</li>
<li><code>ADCIntEnable()</code> 和 <code>ADCIntDisable</code> 使能（失能）一个采样序列中断</li>
<li><code>ADCIntClear()</code> 清除采样序列中断源</li>
<li><code>ADCIntStatus()</code> 获取当前中断状态</li>
</ol>
<h3 id="二、怎样触发中断"><a href="#二、怎样触发中断" class="headerlink" title="二、怎样触发中断"></a>二、怎样触发中断</h3><p>在配置采样通道的时候，如果参数设置有 <code>ADC_CTL_IE</code> 那么当这个通道采集完之后就会产生一个中断。</p>
<h3 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">configureADC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择E3引脚（即CH0）作为ADC输入</span></span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);</span><br><span class="line">    GPIOPinTypeADC(GPIO_PORTE_BASE, GPIO_PIN_3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置采样序列发生器等</span></span><br><span class="line">    ADCSequenceConfigure(ADC0_BASE, <span class="number">0</span>, ADC_TRIGGER_PROCESSOR, <span class="number">0</span>);</span><br><span class="line">    ADCSequenceStepConfigure(ADC0_BASE, <span class="number">0</span>, <span class="number">0</span>,ADC_CTL_IE | ADC_CTL_END | ADC_CTL_CH0);</span><br><span class="line">	</span><br><span class="line">    ADCSequenceEnable(ADC0_BASE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置ADC中断</span></span><br><span class="line">    ADCIntRegister(ADC0_BASE, <span class="number">0</span> , convet);</span><br><span class="line">    ADCIntEnable(ADC0_BASE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、注意"><a href="#四、注意" class="headerlink" title="四、注意"></a>四、注意</h3><p>在写中断函数的时候记得清除中断标记，因为清除中断需要几个时钟周期，所以，我们需要在中断函数一开始就清除中断。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/ADC%20interrupt/" data-id="cko4hr64c000irw0k2mja9igk" data-title="ADC中断" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Analog to Digital Converter" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/Analog%20to%20Digital%20Converter/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/Analog%20to%20Digital%20Converter/">ADC简介</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Analog-to-Digital-Converter（模-数转换器）"><a href="#Analog-to-Digital-Converter（模-数转换器）" class="headerlink" title="Analog to Digital Converter（模-数转换器）"></a>Analog to Digital Converter（模-数转换器）</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>这款单片机有两个完全相同的转换器模块，它们共用12个输入通道。该ADC模块的转换分辨率为12位。</p>
<p>每个ADC模块都包含4个可编程的序列发生器。采样序列发生器（Sample Sequencer 简写为SS）用于采样控制和数据采集。所有序列发生器的实现方法都是相同的，区别仅在于能够捕捉的采样数和FIFO的深度有所不同，捕捉到的每个采样都要存入FIFO中。这四个采样序列发生器，它们可以同时捕获样本。每个序列都可以配置触发事件。第一个序列发生器至多捕获八个样本，第二个和第三个至多捕获四个样本，第四个序列只能捕获一个样本。每一个样本可以在同一路，不同路，或者其他什么顺序。</p>
<p><img src="ADC.png" alt="简介"></p>
<p>如果很多个事件同时被触发的话，可以给样本序列发生器配置优先级确定谁先被捕获。被触发的最高优先级的序列先采样，一定要注意那些频繁触发的事件，如果它们的优先级太高的话，有些低优先级的序列就采不到样了。</p>
<p>ADV数据的硬件过采样可以用来提高精度。过采样的倍率可以2x 4x 8x 16x 32x 或者是32x，但是这样就会相应倍率地降低一个ADC的吞吐量（<a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_4511506f0102xmxw.html">具体可以看这里</a>）。注意所有采样序列只能设置一个统一的硬件过采样倍率。</p>
<p>还可以用软件实现过采样的！单片机支持2x 4x 8x 但是它会相应倍率的降低样本序列的深度的。比如说啊，第一份采样序列地深度是8，在4x过采样模式下，它就只能采两个样本了。这是因为头四个样本被拿去过采样了。每一个采样序列都能设置自己地软件过采样倍率。</p>
<p>一种更加复杂的软件过采样可以用于清除样本深度地减少。如果我们加快ADC触发速率4倍，然后再配置一个4倍地软件过采样，这样就不会减少采样序列容量了，这样做的后果是ADC触发数量就要增加了，因为这种方法需要在ADC驱动本身以外去做调整，所以不被驱动直接支持，如果我们要用这种方法，就不能用驱动里面的函数了。</p>
<p>函数地头文件是driverlib/adc.c 和driverlib/adc.h</p>
<h2 id="二、然后再来看都干了啥"><a href="#二、然后再来看都干了啥" class="headerlink" title="二、然后再来看都干了啥"></a>二、然后再来看都干了啥</h2><h3 id="1-首先使能ADC外设"><a href="#1-首先使能ADC外设" class="headerlink" title="1.首先使能ADC外设"></a>1.首先使能ADC外设</h3><p><code>SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);</code></p>
<h3 id="2-然后开始配置ADC采样序列发生器，主要是配置触发条件和触发优先级"><a href="#2-然后开始配置ADC采样序列发生器，主要是配置触发条件和触发优先级" class="headerlink" title="2.然后开始配置ADC采样序列发生器，主要是配置触发条件和触发优先级"></a>2.然后开始配置ADC采样序列发生器，主要是配置触发条件和触发优先级</h3><p><code>ADCSequenceConfigure();</code><br>这个函数用来配置触发源和采样序列的优先级  </p>
<blockquote>
<p>前两个参数选择是哪个采样序列发生器<br>第三个是触发条件<br>第四个是触发优先级  </p>
</blockquote>
<p>触发条件有这些：</p>
<ul>
<li>处理器触发</li>
<li>AC模块触发</li>
<li>GPIO触发</li>
<li>计时器触发</li>
<li>PWM触发？？以后可以研究一下</li>
<li>一直触发<h3 id="3-配置引脚用于ADC输入"><a href="#3-配置引脚用于ADC输入" class="headerlink" title="3.配置引脚用于ADC输入"></a>3.配置引脚用于ADC输入</h3><code>GPIOPINTypeADC()</code> 配置引脚用于ADC输入 ，注意不是每一个引脚能都拿来作为ADC输入的，<h3 id="4-选取通道并进行余下配置"><a href="#4-选取通道并进行余下配置" class="headerlink" title="4.选取通道并进行余下配置"></a>4.选取通道并进行余下配置</h3><code>ADCSequenceStepConfigure();</code><br>配置采样序列发生器的一个step  <blockquote>
<p>前两个参数选择哪一个采样序列发生器<br>第三个参数是要设置的那个step<br>第四个参数是这个step的设置  </p>
</blockquote>
</li>
</ul>
<p>参数设置分析：这个参数应该是一系列参数的OR，主要设置了一个step的模式（单端输入还是差分输入），选用哪个输入通道，输入完要不要触发中断，以及选择的数字比较器（？？）</p>
<h3 id="5-获取采样结果"><a href="#5-获取采样结果" class="headerlink" title="5.获取采样结果"></a>5.获取采样结果</h3><p><code>ADCSequenceDataGet();</code></p>
<blockquote>
<p>第一个是ADC的基址<br>第二个是ADC的采样序列数<br>第三个填一个32位地址，表示把数填在这里</p>
</blockquote>
<p>其实这个函数还有返回值，返回值就是get到的数</p>
<h3 id="6-使能ADC采样序列发生器"><a href="#6-使能ADC采样序列发生器" class="headerlink" title="6.使能ADC采样序列发生器"></a>6.使能ADC采样序列发生器</h3><p><code>ADCSequenceEnable()</code></p>
<blockquote>
<p>一共两个参数，表示选择的那个采样序列发生器</p>
</blockquote>
<h2 id="三、直接上例程！"><a href="#三、直接上例程！" class="headerlink" title="三、直接上例程！"></a>三、直接上例程！</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义变量用于存储采得样本</span></span><br><span class="line"><span class="keyword">uint32_t</span> ui32Value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使能ADC0模块并等待其准备完成</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);</span><br><span class="line"><span class="keyword">while</span>(!SysCtlPeripheralReady(SYSCTL_PERIPH_ADC0))&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置E3引脚（对应CH0）为这个采样序列发生器的通道</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);</span><br><span class="line">GPIOPinTypeADC(GPIO_PORTE_BASE, GPIO_PIN_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使能第一个采样序列发生器来捕捉CH0的值</span></span><br><span class="line">ADCSequenceConfigure(ADC0_BASE, <span class="number">0</span>, ADC_TRIGGER_PROCESSOR, <span class="number">0</span>);</span><br><span class="line">ADCSequenceStepConfigure(ADC0_BASE, <span class="number">0</span>, <span class="number">0</span>,ADC_CTL_IE | ADC_CTL_END | ADC_CTL_CH0);</span><br><span class="line">ADCSequenceEnable(ADC0_BASE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以后每次触发时都要加上这几句</span></span><br><span class="line">ADCProcessorTrigger(ADC0_BASE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(!ADCIntStatus(ADC0_BASE, <span class="number">0</span>, <span class="literal">false</span>))&#123;&#125;</span><br><span class="line">ADCSequenceDataGet(ADC0_BASE, <span class="number">0</span>, &amp;ui32Value);</span><br></pre></td></tr></table></figure>
<p><img src="ADC引脚.jpg" alt="pin"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/Analog%20to%20Digital%20Converter/" data-id="cko4hr64f000mrw0kgw5k0bn7" data-title="ADC简介" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-GPIO_PWM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/GPIO_PWM/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/GPIO_PWM/">GPIO PWM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="GPIOPinTypePWM"><a href="#GPIOPinTypePWM" class="headerlink" title="GPIOPinTypePWM"></a>GPIOPinTypePWM</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wxc971231/article/details/95355645">感谢这位老哥</a></p>
<p>Configures pin(s) for use by the PWM peripheral.</p>
<blockquote>
<p>配置引脚以用作PWM外设</p>
</blockquote>
<p>Prototype:<br>void<br>GPIOPinTypePWM(uint32_t ui32Port,<br>uint8_t ui8Pins)</p>
<p>Parameters:<br>ui32Port is the base address of the GPIO port.<br>ui8Pins is the bit-packed representation of the pin(s).<br>Description:<br>The PWM pins must be properly configured for the PWM peripheral to function correctly. This function provides a typical configuration for those pin(s); other configurations may work as well depending upon the board setup (for example, using the on-chip pull-ups). </p>
<blockquote>
<p>为了使PWM外设正常工作，一定要正确配置PWM引脚，这个函数为这些引脚提供了典型的配置，其他的配置也可能正确配置。</p>
</blockquote>
<p>The pin(s) are specified using a bit-packed byte, where each bit that is set identifies the pin to be accessed, and where bit 0 of the byte represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.</p>
<p>Note:<br>This function cannot be used to turn any pin into a PWM pin; it only configures a PWM pin<br>for proper operation. Note that a GPIOPinConfigure() function call is also required to properly<br>configure a pin for the PWM function.</p>
<blockquote>
<p>要配置一个引脚发挥PWM功能，还需调用GPIOPinConfigure()函数</p>
</blockquote>
<p>A subset of GPIO pins on Tiva devices, notably those used by the JTAG/SWD interface and<br>any pin capable of acting as an NMI input, are locked against inadvertent reconfiguration.<br>These pins must be unlocked using direct register writes to the relevant GPIO_O_LOCK and<br>GPIO_O_CR registers before this function can be called. Please see the “gpio_jtag” example<br>application for the mechanism required and consult your part datasheet for information on<br>affected pins.</p>
<p>Returns:<br>None.</p>
<h2 id="二、例程"><a href="#二、例程" class="headerlink" title="二、例程"></a>二、例程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置PWM预分频，这里不分频</span></span><br><span class="line">SysCtlPWMClockSet(SYSCTL_PWMDIV_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使能两个模块的时钟</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//复用引脚</span></span><br><span class="line">GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_2);</span><br><span class="line">GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置信号分配</span></span><br><span class="line">GPIOPinConfigure(GPIO_PF2_M1PWM6);</span><br><span class="line">GPIOPinConfigure(GPIO_PF3_M1PWM7);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置PWM发生器</span></span><br><span class="line">PWMGenConfigure(PWM1_BASE, PWM_GEN_3, PWM_GEN_MODE_DOWN | PWM_GEN_MODE_NO_SYNC);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置周期 表示100hz</span></span><br><span class="line">PWMGenPeriodSet(PWM1_BASE, PWM_GEN_3, <span class="number">50000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置占空比</span></span><br><span class="line">PWMPulseWidthSet(PWM1_BASE, PWM_OUT_6, <span class="number">0</span>);</span><br><span class="line">PWMPulseWidthSet(PWM1_BASE, PWM_OUT_7, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使能PWM模块1输出</span></span><br><span class="line">PWMOutputState(PWM1_BASE, (PWM_OUT_6_BIT | PWM_OUT_7_BIT), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使能PWM发生器</span></span><br><span class="line">PWMGenEnable(PWM1_BASE, PWM_GEN_3);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/GPIO_PWM/" data-id="cko4hr64i000srw0k1evt3t93" data-title="GPIO PWM" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-GPIO输出和输入" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/GPIO%E8%BE%93%E5%87%BA%E5%92%8C%E8%BE%93%E5%85%A5/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/GPIO%E8%BE%93%E5%87%BA%E5%92%8C%E8%BE%93%E5%85%A5/">GPIO输入和输出</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="GPIO-输入和输出"><a href="#GPIO-输入和输出" class="headerlink" title="GPIO 输入和输出"></a>GPIO 输入和输出</h1><p>首先使能GPIO接口<br><code>SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</code></p>
<p>接下来设置GPIO模式为输出<br><code>GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_3);</code>  </p>
<ul>
<li><em>如果要设置多个pin的话</em><br><code>GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_2 | GPIO_PIN_4 | GPIO_PIN_5);</code>  </li>
</ul>
<p>最后进行输出<br><code>GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0); 或者 void GPIOPinWrite(Port,Pins,which_pin);</code></p>
<p>GPIO函数一共有三种</p>
<ol>
<li>配置GPIO pins的函数</li>
<li>处理中断的函数</li>
<li>获取pins value的函数</li>
</ol>
<p>配置３２和TI的方式就是不一样的，３２的GPIO是用结构体进行配置，TI则使用函数来进行配置。</p>
<p>TI的普通配置只需要进行GPIO外设使能和方向控制即可。也不是说前面说到的功能模式就不能配置了，如果有需要可以进行其他类型的配置。<br>如果要进行端口高低电平的输出控制，３２和TI也是一样的调用函数来进行配置，分别是：<code>GPIO_SetBits(GPIOE,GPIO_Pin_5);</code>　和　<code>GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0);</code></p>
<p>注意：TI的输出高低电平使用的是同一个函数GPIOPinWrite（），对于３２则使用的是两个函数：GPIO_SetBits（）和GPIO_ResetBit（）即可输出高低电平。TI呢，则不是这样的，就连入口参数也不是和３２一样那么简单，GPIOPinWrite（）入口参数就有三个，分别是GPIO_PORTｘ_BASE，GPIO＿PIN＿ｘ，和０（低电平时候为０，但是高电平时候不是１，而是GPIO＿PIN＿ｘ）。例如PF１输出高电平　：<br>GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, GPIO_PIN_1);</p>
<p>输入输出的模式一般不用管，但应了解浮空输入 上拉输入 下拉输入 模拟输入 开漏输出 推挽输出 复用推挽输出 复用开漏输出</p>
<p>怎样读入呢？</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReadPin1 = GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4);<span class="comment">//检测</span></span><br><span class="line"><span class="keyword">if</span>((ReadPin1&amp;GPIO_PIN_4) != GPIO_PIN_4) &#123; <span class="comment">//如果按下</span></span><br><span class="line">    SysCtlDelay(<span class="number">20</span>*(SysCtlClockGet()/<span class="number">3000</span>));<span class="comment">//消抖</span></span><br><span class="line">    ReadPin1 = GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4);<span class="comment">//再次检测</span></span><br><span class="line">    <span class="keyword">if</span>((ReadPin1&amp;GPIO_PIN_4) != GPIO_PIN_4) &#123;<span class="comment">//再次判断</span></span><br><span class="line">        KeyPress1 = <span class="literal">true</span>;<span class="comment">//如果按下，则置一个标志位</span></span><br><span class="line">        <span class="keyword">while</span>(!GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4))&#123;&#125;<span class="comment">//等按键松开</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="GPIO输出最终模板"><a href="#GPIO输出最终模板" class="headerlink" title="GPIO输出最终模板"></a>GPIO输出最终模板</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使能GPIO外设</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line"><span class="comment">//设置引脚为GPIO输出模式</span></span><br><span class="line">GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_3);</span><br><span class="line"><span class="comment">//引脚输出</span></span><br><span class="line">GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_3, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="部分函数研究"><a href="#部分函数研究" class="headerlink" title="部分函数研究"></a>部分函数研究</h2><ol>
<li><code>GPIODirModeSet()</code><br>描述：设置了管脚的方向是向内、向外还是硬件控制</li>
<li><code>GPIOPadConfigSet()</code><br> 描述：设置了一些引脚的输出驱动强度，和引脚类型<br> GPIO_PIN_TYPE_STD 推挽输出 可以输出高低电平<br> GPIO_PIN_TYPE_STD_WPU 推挽——弱上拉<br> GPIO_PIN_TYPE_STD_WPD 推挽——弱下拉<br> GPIO_PIN_TYPE_OD 开漏输出 IO 输出 0 接 GND， IO 输出 1，悬空，需要外接上拉电阻，才能实现输出<br> GPIO_PIN_TYPE_ANALOG 模拟输出<br> GPIO_PIN_TYPE_WAKE_HIGH 于hibernation mode 有关<br> GPIO_PIN_TYPE_WAKE_LOW  </li>
<li><code>GPIOPinConfigure()</code></li>
<li><code>GPIOPinRead()</code></li>
<li><code>GPIOPinWrite()</code></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/GPIO%E8%BE%93%E5%87%BA%E5%92%8C%E8%BE%93%E5%85%A5/" data-id="cko4hr64j000urw0kaguoa694" data-title="GPIO输入和输出" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Pulse Width Modulator" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/Pulse%20Width%20Modulator/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/Pulse%20Width%20Modulator/">PWM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Each instance of a Tiva PWM module provides up to four instances of a PWM generator block, and an output control block. Each generator block has two PWM output signals, which can be operated independently or as a pair of signals with dead band delays inserted. Each generator block also has an interrupt output and a trigger output. The control block determines the polarity of the PWM signals and which signals are passed through to the pins.</p>
<blockquote>
<p>每个PWM提供了最多4个PWM发生器和一个输出控制模块，每一个发生器能产生两个PWM输出信号，可以独立操作，也可以作为一对插入了死区延迟的信号运行。每一个生成器块还有一个中断输出和一个触发输出，控制块确定PWM信号的极性以及哪些信号传递到引脚。</p>
</blockquote>
<p>Some of the features of the Tiva PWM module are:<br>Up to four generator blocks, each containing<br>• One 16-bit down or up/down counter<br>• Two comparators<br>• PWM generator<br>• Dead band generator</p>
<blockquote>
<p>至多4个产生模块，每一个产生模块包括</p>
<blockquote>
<p>一个十六位的向上/向下计数器</p>
<p>两个比较器</p>
<p>PWM产生器</p>
<p>死区产生器</p>
</blockquote>
</blockquote>
<p>Control block<br>• PWM output enable<br>• Output polarity control<br>• Synchronization<br>• Fault handling<br>• Interrupt status</p>
<blockquote>
<p>控制模块有</p>
<blockquote>
<p>PWM输出使能</p>
<p>输出极性控制</p>
<p>错误处理</p>
<p>中断状态</p>
</blockquote>
</blockquote>
<p>This driver is contained in driverlib/pwm.c, with driverlib/pwm.h containing the API declarations for use by applications.</p>
<h2 id="细节描述"><a href="#细节描述" class="headerlink" title="细节描述"></a>细节描述</h2><p>These functions perform high-level operations on PWM modules.</p>
<blockquote>
<p>这些模块表现了高水平的对PWM的操作</p>
</blockquote>
<p>The following functions provide the user with a way to configure the PWM for the most common operations, such as setting the period, generating left- and center-aligned pulses, modifying the pulse width, and controlling interrupts, triggers, and output characteristics. However, the PWM module is very versatile and can be configured in a number of different ways, many of which are beyond the scope of this API. In order to fully exploit the many features of the PWM module, users are advised to use register access macros.</p>
<blockquote>
<p>接下来的函数为用户提供了一种配置PWM做最普通操作的方式，这些操作有设定周期，产生左对齐/中心对齐的脉冲，调节脉冲宽度，控制中断/触发/输出特征等功能。然而，PWM模块非常的强大，可以用很多种方式设置，许多用的都不是这些API。为了能充分利用PWM模块的诸多功能，我们推荐用户使用寄存器。</p>
</blockquote>
<p>When discussing the various components of a PWM module, this API uses the following labeling convention:</p>
<p>The generator blocks are called Gen0, Gen1, Gen2 and Gen3.</p>
<blockquote>
<p>产生器模块被称为Gen0, Gen1, Gen2 and Gen3.</p>
</blockquote>
<p>The two PWM output signals associated with each generator block are called OutA and OutB.</p>
<blockquote>
<p>与产生器模块相关的两个PWM输出信号被称为OutA和OutB</p>
</blockquote>
<p>The output signals are called PWM0, PWM1, PWM2, PWM3, PWM4, PWM5, PWM6 and PWM7.</p>
<blockquote>
<p>输出信号被称为PWM0, PWM1, PWM2, PWM3, PWM4, PWM5, PWM6 and PWM7.</p>
</blockquote>
<p>PWM0 and PWM1 are associated with Gen0, PWM2 and PWM3 are associated with Gen1, PWM4 and PWM5 are associated with Gen2 and PWM6 and PWM7 are associated with Gen3.</p>
<blockquote>
<p>PWM0和PWM1与Gen0相关联，PWM2和PWM3与Gen1相关联，PWM4和PWM5与Gen2相关联，PWM6和PWM7与Gen3相关联。</p>
</blockquote>
<p>Also, as a simplifying assumption for this API, comparator A for each generator block is used exclusively to adjust the pulse width of the even numbered PWM outputs (PWM0, PWM2, PWM4 and PWM6). In addition, comparator B is used exclusively for the odd numbered PWM outputs (PWM1, PWM3, PWM5 and PWM7).<br>Note that the number of generators and PWM outputs supported varies depending upon the Tiva part in use. Please consult the datasheet for the part you are using to determine whether it supports 1 or 2 modules with 3 or 4 generators each and 6 or 8 outputs each. </p>
<blockquote>
<p>另外，作为对此API的简化假设，每个生成器模块的比较器仅用于调整偶数个PWM输出的脉冲高度，比较器A仅用于计数PWM输出</p>
<p>请注意，支持的生成器和 PWM 输出的数量因使用的 Tiva 部件而异。请参阅您使用的部件的数据表，以确定它是否支持 1 个或 2 个模块，每个模块有 3 个或 4 个生成器，每个模块有 6 个或 8 个输出。</p>
</blockquote>
<p><strong>我们这款单片机包括两个PWM模块，总共有16个输出</strong></p>
<p>这次我们直接看例程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Enable the PWM0 peripheral</span></span><br><span class="line"><span class="comment">// 使能PWM外设</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM0);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Wait for the PWM0 module to be ready.</span></span><br><span class="line"><span class="comment">// 等待PWM模块准备好</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span>(!SysCtlPeripheralReady(SYSCTL_PERIPH_PWM0))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Configure the PWM generator for count down mode with immediate updates</span></span><br><span class="line"><span class="comment">// to the parameters.</span></span><br><span class="line"><span class="comment">// 配置PWM产生器，并设置器为向下计数模式，和非同步模式</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMGenConfigure(PWM_BASE, PWM_GEN_0,PWM_GEN_MODE_DOWN | PWM_GEN_MODE_NO_SYNC);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the period. For a 50 KHz frequency, the period = 1/50,000, or 20</span></span><br><span class="line"><span class="comment">// microseconds. For a 20 MHz clock, this translates to 400 clock ticks.</span></span><br><span class="line"><span class="comment">// Use this value to set the period.</span></span><br><span class="line"><span class="comment">// 设置周期。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMGenPeriodSet(PWM_BASE, PWM_GEN_0, <span class="number">400</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the pulse width of PWM0 for a 25% duty cycle.</span></span><br><span class="line"><span class="comment">// 脉冲宽度设置</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMPulseWidthSet(PWM_BASE, PWM_OUT_0, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the pulse width of PWM1 for a 75% duty cycle.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMPulseWidthSet(PWM_BASE, PWM_OUT_1, <span class="number">300</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Start the timers in generator 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMGenEnable(PWM_BASE, PWM_GEN_0);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Enable the outputs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMOutputState(PWM_BASE, (PWM_OUT_0_BIT | PWM_OUT_1_BIT), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h2 id="关注如下函数"><a href="#关注如下函数" class="headerlink" title="关注如下函数"></a>关注如下函数</h2><h4 id="PWMGenConfigure"><a href="#PWMGenConfigure" class="headerlink" title="PWMGenConfigure"></a>PWMGenConfigure</h4><p>用于配置PWM</p>
<p>This function is used to set the mode of operation for a PWM generator. The counting mode, synchronization mode, and debug behavior are all configured. After configuration, the generator is left in the disabled state.</p>
<blockquote>
<p>这个函数用于设置PWM产生器的操作模式。计数模式，同步模式，调试模式都在这里设置。设置之后，产生器处于关闭状态。</p>
</blockquote>
<p>A PWM generator can count in two different modes: count down mode or count up/down mode. In count down mode, it counts from a value down to zero, and then resets to the preset value, producing left-aligned PWM signals (that is, the rising edge of the two PWM signals produced by the generator occur at the same time). In count up/down mode, it counts up from zero to the preset value, counts back down to zero, and then repeats the process, producing centeraligned PWM signals (that is, the middle of the high/low period of the PWM signals produced by the generator occurs at the same time).</p>
<blockquote>
<p>PWM产生器可以用两种计数模式计数，向下计数模式和向上/向下计数模式。</p>
<p>在向下计数模式中，它从一个值向下数到零，然后恢复到预设值，产生一个左对齐的PWM信号（也就是说，两个产生器产生的信号的升边同时出现）在向上向下计数模式中，它从零数到预设值，再数回到零，反复这个过程，产生的是中心对齐的PWM信号（也就是说，产生器产生的PWM信号的周期的中间时刻是同时发生的）<strong>每个生成器不是能产生两个PWM信号嘛</strong></p>
</blockquote>
<p>When the PWM generator parameters (period and pulse width) are modified, their effect on the output PWM signals can be delayed. In synchronous mode, the parameter updates are not applied until a synchronization event occurs. This mode allows multiple parameters to be modified and take effect simultaneously, instead of one at a time. Additionally, parameters to multiple PWM generators in synchronous mode can be updated simultaneously, allowing them to be treated as if they were a unified generator. In non-synchronous mode, the parameter updates are not delayed until a synchronization event. In either mode, the parameter updates only occur when the counter is at zero to help prevent oddly formed PWM signals during the update (that is, a PWM pulse that is too short or too long).</p>
<blockquote>
<p>当PWM脉冲产生器的参数（周期和脉冲宽度）被修改时，它们对PWM信号的影响可能会延迟。</p>
<p>在同步模式下，直到发生同步时间时应用参数才被更新。此模式允许多个参数同时修改并生效，而不是一次一个参数。此外，同步模式下多个 PWM 生成器的参数可以同时更新，从而可以将它们视为统一生成器。</p>
<p>在非同步模式下，参数 更新不会延迟到同步事件，在任意模式下，参数更新仅在计数器为零时在会发生，用以防止更新期间产生奇怪的PWM信号。</p>
</blockquote>
<p>The PWM generator can either pause or continue running when the processor is stopped via the debugger. If configured to pause, it continues to count until it reaches zero, at which point it pauses until the processor is restarted. If configured to continue running, it keeps counting as if nothing had happened.</p>
<blockquote>
<p>当调试器使处理器停止时，PWM产生器可以停止/继续运行如果配置为暂停，则它将继续计数，直到达到零，此时它会暂停，直到重新启动处理器。如果配置为继续运行，则继续计数，就像什么都没发生一样。</p>
</blockquote>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212211525865.png" alt="image-20201212211525865"></p>
<p>这是这个函数的参数，第一部分是PWM模块的基址，第二部分是PWM产生器，究竟是GEN几，最后是配置参数。</p>
<p>那么有哪些参数呢？</p>
<p>PWM_GEN_MODE_DOWN or PWM_GEN_MODE_UP_DOWN to specify the counting<br>mode</p>
<p><strong>计数模式，就是向上模式还是向上向下模式</strong></p>
<p>PWM_GEN_MODE_SYNC or PWM_GEN_MODE_NO_SYNC to specify the counter load<br>and comparator update synchronization mode</p>
<p><strong>不晓得</strong></p>
<p>PWM_GEN_MODE_DBG_RUN or PWM_GEN_MODE_DBG_STOP to specify the debug<br>behavior</p>
<p><strong>配置了debug的行为</strong></p>
<p>PWM_GEN_MODE_GEN_NO_SYNC, PWM_GEN_MODE_GEN_SYNC_LOCAL, or<br>PWM_GEN_MODE_GEN_SYNC_GLOBAL to specify the update synchronization mode<br>for generator counting mode changes</p>
<p><strong>不晓得</strong></p>
<p>PWM_GEN_MODE_DB_NO_SYNC, PWM_GEN_MODE_DB_SYNC_LOCAL, or<br>PWM_GEN_MODE_DB_SYNC_GLOBAL to specify the deadband parameter synchronization<br>mode</p>
<p><strong>指定死区参数同步模式</strong></p>
<p>PWM_GEN_MODE_FAULT_LATCHED or PWM_GEN_MODE_FAULT_UNLATCHED to<br>specify whether fault conditions are latched or not</p>
<p><strong>指定是否锁定故障条件</strong></p>
<p>PWM_GEN_MODE_FAULT_MINPER or PWM_GEN_MODE_FAULT_NO_MINPER to<br>specify whether minimum fault period support is required</p>
<p><strong>确定是否需要最小错误周期支持</strong></p>
<p>PWM_GEN_MODE_FAULT_EXT or PWM_GEN_MODE_FAULT_LEGACY to specify<br>whether extended fault source selection support is enabled or not</p>
<p><strong>指定是否启用扩展故障源选择支持</strong></p>
<!--死区就是中性区或者是不作用区-->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/Pulse%20Width%20Modulator/" data-id="cko4hr64l000yrw0k5xuocz2n" data-title="PWM" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Interrupt Controller(NVIC)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/Interrupt%20Controller(NVIC)/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/Interrupt%20Controller(NVIC)/">中断控制器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Interrupt-Controller-NVIC"><a href="#Interrupt-Controller-NVIC" class="headerlink" title="Interrupt Controller(NVIC)"></a>Interrupt Controller(NVIC)</h1><p>The interrupt controller API provides a set of functions for dealing with the Nested Vectored Interrupt<br>Controller (NVIC). Functions are provided to enable and disable interrupts, register interrupt<br>handlers, and set the priority of interrupts.</p>
<blockquote>
<p>中断控制器API提供了一系列与内置向量式中断控制器有关的函数，这些函数能使能/使不能中断，注册中断，设置中断优先级等</p>
</blockquote>
<p>The NVIC provides global interrupt masking, prioritization, and handler dispatching. Devices within<br>the Tiva family support up to 154 interrupt sources and eight priority levels. Individual interrupt<br>sources can be masked, and the processor interrupt can be globally masked as well (without affecting<br>the individual source masks).</p>
<blockquote>
<p>NVIC提供了全局中断屏蔽，优先级和处理器调度功能，在Tiva系列设备里至多支持154个中断和8个中断级，单个中断源可以被屏蔽，处理器屏蔽也可以被全局屏蔽（不影响单个中断源的屏蔽哦）</p>
</blockquote>
<p>The NVIC is tightly coupled with the Cortex-M microprocessor. When the processor responds to<br>an interrupt, the NVIC supplies the address of the function to handle the interrupt directly to the<br>processor. This action eliminates the need for a global interrupt handler that queries the interrupt<br>controller to determine the cause of the interrupt and branch to the appropriate handler, reducing<br>interrupt response time.</p>
<blockquote>
<p>NVIC紧密搭配着cortex_M微处理器。当处理器对中断作出反应时，NVIC直接把处理中断的函数的地址提供给处理器，此操作无需使用全局中断处理程序来查询中断控制器以确定中断的原因，并分支到相应的处理程序，从而减少中断响应时间。  </p>
</blockquote>
<p>The interrupt prioritization in the NVIC allows higher priority interrupts to be handled before lower<br>priority interrupts, as well as allowing preemption of lower priority interrupt handlers by higher priority<br>interrupts. Again, this helps reduce interrupt response time (for example, a 1 ms system control<br>interrupt is not held off by the execution of a lower priority 1 second housekeeping interrupt handler).</p>
<blockquote>
<p>中断处理优先级使得高优先级的中断在低优先级中断之前处理，并允许高优先级中断抢占低优先级中断。这还能减少中断响应时间，比如1ms的系统控制中断不会被更低优先级的1ms中断所延迟。</p>
</blockquote>
<p>Sub-prioritization is also possible; instead of having N bits of preemptable prioritization, the NVIC<br>can be configured (via software) for N - M bits of preemptable prioritization and M bits of sub-priority.<br>In this scheme, two interrupts with the same preemptable prioritization but different sub-priorities<br>do not cause a preemption; tail chaining is used instead to process the two interrupts back-to-back.</p>
<blockquote>
<p>还可以设置子优先级，如果不设置N位可抢占优先级的话，可以通过软件设置N-M个可抢占优先级和M个子优先级，在这种方案下，两个仅仅子优先级不同的可抢占中断不会导致抢占，单片机会使用尾链来来回处理两个中断</p>
</blockquote>
<p>If two interrupts with the same priority (and sub-priority if so configured) are asserted at the same<br>time, the one with the lower interrupt number is processed first. The NVIC keeps track of the nesting<br>of interrupt handlers, allowing the processor to return from interrupt context only once all nested<br>and pending interrupts have been handled.</p>
<blockquote>
<p>如果两个中断有相同的优先级（和子优先级）还被同时触发了，中断数更低的有限执行，NVIC会跟踪中断处理程序的嵌套，要求处理器在处理完所有被嵌套和挂起的中断后再返回</p>
</blockquote>
<p>Interrupt handlers can be configured in one of two ways; statically at compile time or dynamically at<br>run time. Static configuration of interrupt handlers is accomplished by editing the interrupt handler<br>table in the application’s startup code. When statically configured, the interrupts must be explicitly<br>enabled in the NVIC via IntEnable() before the processor can respond to the interrupt (in addition to<br>any interrupt enabling required within the peripheral itself). Statically configuring the interrupt table<br>provides the fastest interrupt response time because the stacking operation (a write to SRAM) can<br>be performed in parallel with the interrupt handler table fetch (a read from Flash), as well as the<br>prefetch of the interrupt handler itself (assuming it is also in Flash).</p>
<blockquote>
<p>中断处理程序可以用两种方式中的一种来设置，编译时设置或者运行时动态设置。静态配置使用的是IntEnable（）函数完成的，运行的时候静态配置的中断处理程序更快一点。</p>
</blockquote>
<p>Alternatively, interrupts can be configured at run-time using IntRegister() (or the analog in each<br>individual driver). When using IntRegister(), the interrupt must also be enabled as before; when<br>using the analogue in each individual driver, IntEnable() is called by the driver and does not need<br>to be called by the application. Run-time configuration of interrupts adds a small latency to the<br>interrupt response time because the stacking operation (a write to SRAM) and the interrupt handler<br>table fetch (a read from SRAM) must be performed sequentially.</p>
<blockquote>
<p>在运行时设置的话，需要用到IntRegister()函数，会有延迟。</p>
</blockquote>
<p>Run-time configuration of interrupt handlers requires that the interrupt handler table be placed on a<br>1-kB boundary in SRAM (typically this is at the beginning of SRAM). Failure to do so results in an<br>incorrect vector address being fetched in response to an interrupt. The vector table is in a section<br>called “vtable” and must be placed appropriately with a linker script.</p>
<blockquote>
<p>中断处理程序的配置需要将中断处理表放在SARM1kb的边缘上。。。。。</p>
</blockquote>
<p>This driver is contained in driverlib/interrupt.c, with driverlib/interrupt.h containing<br>the API declarations for use by applications.</p>
<p>他的函数非常少</p>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212164149113.png" alt="image-20201212164149113"></p>
<p>前两个是使能/使不能一个中断</p>
<p>第三个 确认一个中断是否在运行，如果一个中断在运行的话，会返回一个非零数</p>
<p>第四个 第五个 使能/使不能处理器中断</p>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212164210385.png" alt="image-20201212164210385"></p>
<p>第一个 第二个 挂起/放下一个中断</p>
<p>第三个 获取一个中断的优先级</p>
<p>第四个 获取中断控制器的优先级分组 就是返回可抢占优先级的位数</p>
<p>第五个 设置可抢占优先级的位数</p>
<p>第六个 获取优先级屏蔽 </p>
<blockquote>
<p>This function gets the current setting of the interrupt priority masking level. The value returned is the priority level such that all interrupts of that and lesser priority are masked. A value of 0 means that priority masking is disabled.<br>Smaller numbers correspond to higher interrupt priorities. So for example a priority level mask of 4 allows interrupts of priority level 0-3, and interrupts with a numerical priority of 4 and greater are blocked.<br>The hardware priority mechanism only looks at the upper 3 bits of the priority level, so any prioritization must be performed in those bits.</p>
</blockquote>
<p>第七个 设置优先级屏蔽</p>
<p>第八个 设置中断优先级</p>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212165114559.png" alt="image-20201212165114559"></p>
<p>第一个 注册一个函数，中断发生是就调用它</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// UART 0 interrupt handler.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">UART0Handler(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Handle interrupt.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the UART 0 interrupt handler.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">IntRegister(INT_UART0, UART0Handler);</span><br></pre></td></tr></table></figure>
<p>第二个 触发一个中断 （直接触发）</p>
</blockquote>
<p>第三个 解注册一个中断</p>
<p>所以怎样使用中断呢？</p>
<p>直接去对应外设那里去查询中断怎样使用，然后回来使能中断即可，有需要就设置优先级啊，子优先级啊，屏蔽啊等等。</p>
<p>有需要还可以直接触发一个中断的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/Interrupt%20Controller(NVIC)/" data-id="cko4hr64m0010rw0k0i3s60dg" data-title="中断控制器" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/midi/" rel="tag">midi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stm32/" rel="tag">stm32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%9A%E4%BF%A1/" rel="tag">通信</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/midi/" style="font-size: 10px;">midi</a> <a href="/tags/stm32/" style="font-size: 15px;">stm32</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 20px;">单片机</a> <a href="/tags/%E9%80%9A%E4%BF%A1/" style="font-size: 10px;">通信</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/30/cc2541/">CC2541</a>
          </li>
        
          <li>
            <a href="/2021/03/28/999-project/">stm32_template</a>
          </li>
        
          <li>
            <a href="/2021/03/27/004-USART/">stm32_USART</a>
          </li>
        
          <li>
            <a href="/2021/03/26/003-systick/">stm32-systick</a>
          </li>
        
          <li>
            <a href="/2021/03/23/002-GPIO/">stm32_GPIO</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 smallcracker<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Welcome to smallcracker&#39;s personal website</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Welcome to smallcracker&#39;s personal website">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Welcome to smallcracker&#39;s personal website">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="smallcracker">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Welcome to smallcracker's personal website" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Welcome to smallcracker&#39;s personal website</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">联系方式：1426090870</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-ADC interrupt" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/ADC%20interrupt/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/ADC%20interrupt/">ADC中断</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ADC中断"><a href="#ADC中断" class="headerlink" title="ADC中断"></a>ADC中断</h1><h3 id="一、相关函数介绍"><a href="#一、相关函数介绍" class="headerlink" title="一、相关函数介绍"></a>一、相关函数介绍</h3><ol>
<li><code>ADCIntRegister()</code> 和<code>ADCIntUnregister()</code>用于为ADC中断注册（注销）一个中断函数</li>
<li><code>ADCIntEnable()</code> 和 <code>ADCIntDisable</code> 使能（失能）一个采样序列中断</li>
<li><code>ADCIntClear()</code> 清除采样序列中断源</li>
<li><code>ADCIntStatus()</code> 获取当前中断状态</li>
</ol>
<h3 id="二、怎样触发中断"><a href="#二、怎样触发中断" class="headerlink" title="二、怎样触发中断"></a>二、怎样触发中断</h3><p>在配置采样通道的时候，如果参数设置有 <code>ADC_CTL_IE</code> 那么当这个通道采集完之后就会产生一个中断。</p>
<h3 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">configureADC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择E3引脚（即CH0）作为ADC输入</span></span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);</span><br><span class="line">    GPIOPinTypeADC(GPIO_PORTE_BASE, GPIO_PIN_3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置采样序列发生器等</span></span><br><span class="line">    ADCSequenceConfigure(ADC0_BASE, <span class="number">0</span>, ADC_TRIGGER_PROCESSOR, <span class="number">0</span>);</span><br><span class="line">    ADCSequenceStepConfigure(ADC0_BASE, <span class="number">0</span>, <span class="number">0</span>,ADC_CTL_IE | ADC_CTL_END | ADC_CTL_CH0);</span><br><span class="line">	</span><br><span class="line">    ADCSequenceEnable(ADC0_BASE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置ADC中断</span></span><br><span class="line">    ADCIntRegister(ADC0_BASE, <span class="number">0</span> , convet);</span><br><span class="line">    ADCIntEnable(ADC0_BASE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、注意"><a href="#四、注意" class="headerlink" title="四、注意"></a>四、注意</h3><p>在写中断函数的时候记得清除中断标记，因为清除中断需要几个时钟周期，所以，我们需要在中断函数一开始就清除中断。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/ADC%20interrupt/" data-id="ckmm8nzvy000fsk3db20sahcz" data-title="ADC中断" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-GPIO_PWM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/GPIO_PWM/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/GPIO_PWM/">GPIO PWM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="GPIOPinTypePWM"><a href="#GPIOPinTypePWM" class="headerlink" title="GPIOPinTypePWM"></a>GPIOPinTypePWM</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wxc971231/article/details/95355645">感谢这位老哥</a></p>
<p>Configures pin(s) for use by the PWM peripheral.</p>
<blockquote>
<p>配置引脚以用作PWM外设</p>
</blockquote>
<p>Prototype:<br>void<br>GPIOPinTypePWM(uint32_t ui32Port,<br>uint8_t ui8Pins)</p>
<p>Parameters:<br>ui32Port is the base address of the GPIO port.<br>ui8Pins is the bit-packed representation of the pin(s).<br>Description:<br>The PWM pins must be properly configured for the PWM peripheral to function correctly. This function provides a typical configuration for those pin(s); other configurations may work as well depending upon the board setup (for example, using the on-chip pull-ups). </p>
<blockquote>
<p>为了使PWM外设正常工作，一定要正确配置PWM引脚，这个函数为这些引脚提供了典型的配置，其他的配置也可能正确配置。</p>
</blockquote>
<p>The pin(s) are specified using a bit-packed byte, where each bit that is set identifies the pin to be accessed, and where bit 0 of the byte represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.</p>
<p>Note:<br>This function cannot be used to turn any pin into a PWM pin; it only configures a PWM pin<br>for proper operation. Note that a GPIOPinConfigure() function call is also required to properly<br>configure a pin for the PWM function.</p>
<blockquote>
<p>要配置一个引脚发挥PWM功能，还需调用GPIOPinConfigure()函数</p>
</blockquote>
<p>A subset of GPIO pins on Tiva devices, notably those used by the JTAG/SWD interface and<br>any pin capable of acting as an NMI input, are locked against inadvertent reconfiguration.<br>These pins must be unlocked using direct register writes to the relevant GPIO_O_LOCK and<br>GPIO_O_CR registers before this function can be called. Please see the “gpio_jtag” example<br>application for the mechanism required and consult your part datasheet for information on<br>affected pins.</p>
<p>Returns:<br>None.</p>
<h2 id="二、例程"><a href="#二、例程" class="headerlink" title="二、例程"></a>二、例程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置PWM预分频，这里不分频</span></span><br><span class="line">SysCtlPWMClockSet(SYSCTL_PWMDIV_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使能两个模块的时钟</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//复用引脚</span></span><br><span class="line">GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_2);</span><br><span class="line">GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置信号分配</span></span><br><span class="line">GPIOPinConfigure(GPIO_PF2_M1PWM6);</span><br><span class="line">GPIOPinConfigure(GPIO_PF3_M1PWM7);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置PWM发生器</span></span><br><span class="line">PWMGenConfigure(PWM1_BASE, PWM_GEN_3, PWM_GEN_MODE_DOWN | PWM_GEN_MODE_NO_SYNC);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置周期 表示100hz</span></span><br><span class="line">PWMGenPeriodSet(PWM1_BASE, PWM_GEN_3, <span class="number">50000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置占空比</span></span><br><span class="line">PWMPulseWidthSet(PWM1_BASE, PWM_OUT_6, <span class="number">0</span>);</span><br><span class="line">PWMPulseWidthSet(PWM1_BASE, PWM_OUT_7, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使能PWM模块1输出</span></span><br><span class="line">PWMOutputState(PWM1_BASE, (PWM_OUT_6_BIT | PWM_OUT_7_BIT), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使能PWM发生器</span></span><br><span class="line">PWMGenEnable(PWM1_BASE, PWM_GEN_3);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/GPIO_PWM/" data-id="ckmm8nzw1000lsk3d2f44gz8m" data-title="GPIO PWM" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-GPIO输出和输入" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/GPIO%E8%BE%93%E5%87%BA%E5%92%8C%E8%BE%93%E5%85%A5/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/GPIO%E8%BE%93%E5%87%BA%E5%92%8C%E8%BE%93%E5%85%A5/">GPIO输入和输出</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="GPIO-输入和输出"><a href="#GPIO-输入和输出" class="headerlink" title="GPIO 输入和输出"></a>GPIO 输入和输出</h1><p>首先使能GPIO接口<br><code>SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</code></p>
<p>接下来设置GPIO模式为输出<br><code>GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_3);</code>  </p>
<ul>
<li><em>如果要设置多个pin的话</em><br><code>GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_2 | GPIO_PIN_4 | GPIO_PIN_5);</code>  </li>
</ul>
<p>最后进行输出<br><code>GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0); 或者 void GPIOPinWrite(Port,Pins,which_pin);</code></p>
<p>GPIO函数一共有三种</p>
<ol>
<li>配置GPIO pins的函数</li>
<li>处理中断的函数</li>
<li>获取pins value的函数</li>
</ol>
<p>配置３２和TI的方式就是不一样的，３２的GPIO是用结构体进行配置，TI则使用函数来进行配置。</p>
<p>TI的普通配置只需要进行GPIO外设使能和方向控制即可。也不是说前面说到的功能模式就不能配置了，如果有需要可以进行其他类型的配置。<br>如果要进行端口高低电平的输出控制，３２和TI也是一样的调用函数来进行配置，分别是：<code>GPIO_SetBits(GPIOE,GPIO_Pin_5);</code>　和　<code>GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0);</code></p>
<p>注意：TI的输出高低电平使用的是同一个函数GPIOPinWrite（），对于３２则使用的是两个函数：GPIO_SetBits（）和GPIO_ResetBit（）即可输出高低电平。TI呢，则不是这样的，就连入口参数也不是和３２一样那么简单，GPIOPinWrite（）入口参数就有三个，分别是GPIO_PORTｘ_BASE，GPIO＿PIN＿ｘ，和０（低电平时候为０，但是高电平时候不是１，而是GPIO＿PIN＿ｘ）。例如PF１输出高电平　：<br>GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, GPIO_PIN_1);</p>
<p>输入输出的模式一般不用管，但应了解浮空输入 上拉输入 下拉输入 模拟输入 开漏输出 推挽输出 复用推挽输出 复用开漏输出</p>
<p>怎样读入呢？</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReadPin1 = GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4);<span class="comment">//检测</span></span><br><span class="line"><span class="keyword">if</span>((ReadPin1&amp;GPIO_PIN_4) != GPIO_PIN_4) &#123; <span class="comment">//如果按下</span></span><br><span class="line">    SysCtlDelay(<span class="number">20</span>*(SysCtlClockGet()/<span class="number">3000</span>));<span class="comment">//消抖</span></span><br><span class="line">    ReadPin1 = GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4);<span class="comment">//再次检测</span></span><br><span class="line">    <span class="keyword">if</span>((ReadPin1&amp;GPIO_PIN_4) != GPIO_PIN_4) &#123;<span class="comment">//再次判断</span></span><br><span class="line">        KeyPress1 = <span class="literal">true</span>;<span class="comment">//如果按下，则置一个标志位</span></span><br><span class="line">        <span class="keyword">while</span>(!GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4))&#123;&#125;<span class="comment">//等按键松开</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="GPIO输出最终模板"><a href="#GPIO输出最终模板" class="headerlink" title="GPIO输出最终模板"></a>GPIO输出最终模板</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使能GPIO外设</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line"><span class="comment">//设置引脚为GPIO输出模式</span></span><br><span class="line">GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_3);</span><br><span class="line"><span class="comment">//引脚输出</span></span><br><span class="line">GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_3, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="部分函数研究"><a href="#部分函数研究" class="headerlink" title="部分函数研究"></a>部分函数研究</h2><ol>
<li><code>GPIODirModeSet()</code><br>描述：设置了管脚的方向是向内、向外还是硬件控制</li>
<li><code>GPIOPadConfigSet()</code><br> 描述：设置了一些引脚的输出驱动强度，和引脚类型<br> GPIO_PIN_TYPE_STD 推挽输出 可以输出高低电平<br> GPIO_PIN_TYPE_STD_WPU 推挽——弱上拉<br> GPIO_PIN_TYPE_STD_WPD 推挽——弱下拉<br> GPIO_PIN_TYPE_OD 开漏输出 IO 输出 0 接 GND， IO 输出 1，悬空，需要外接上拉电阻，才能实现输出<br> GPIO_PIN_TYPE_ANALOG 模拟输出<br> GPIO_PIN_TYPE_WAKE_HIGH 于hibernation mode 有关<br> GPIO_PIN_TYPE_WAKE_LOW  </li>
<li><code>GPIOPinConfigure()</code></li>
<li><code>GPIOPinRead()</code></li>
<li><code>GPIOPinWrite()</code></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/GPIO%E8%BE%93%E5%87%BA%E5%92%8C%E8%BE%93%E5%85%A5/" data-id="ckmm8nzw1000nsk3d0r1ebvog" data-title="GPIO输入和输出" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-GPIO_interrupt" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/GPIO_interrupt/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/GPIO_interrupt/">GPIO中断</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="GPIO中断"><a href="#GPIO中断" class="headerlink" title="GPIO中断"></a>GPIO中断</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wxc971231/article/details/95173394">资料来源</a></p>
<h2 id="一、函数介绍"><a href="#一、函数介绍" class="headerlink" title="一、函数介绍"></a>一、函数介绍</h2><h4 id="（1）void-GPIOIntTypeSet-uint32-t-ui32Port-uint8-t-ui8Pins-uint32-t-ui32IntType"><a href="#（1）void-GPIOIntTypeSet-uint32-t-ui32Port-uint8-t-ui8Pins-uint32-t-ui32IntType" class="headerlink" title="（1）void GPIOIntTypeSet(uint32_t ui32Port, uint8_t ui8Pins,uint32_t ui32IntType)"></a>（1）void GPIOIntTypeSet(uint32_t ui32Port, uint8_t ui8Pins,uint32_t ui32IntType)</h4><ol>
<li>功能：设置指定引脚的中断触发类型.</li>
<li>参数:<br>（1）ui32Port： GPIO口的基地址<br>（2）ui8Pins： 多个bit-packed格式表示的引脚<br>（3）ui32IntType： 中断触发类型(有以下类型)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_FALLING_EDGE       0x00000000  <span class="comment">// Interrupt on falling edge</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_RISING_EDGE        0x00000004  <span class="comment">// Interrupt on rising edge</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_BOTH_EDGES         0x00000001  <span class="comment">// Interrupt on both edges</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_LOW_LEVEL          0x00000002  <span class="comment">// Interrupt on low level</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_HIGH_LEVEL         0x00000006  <span class="comment">// Interrupt on high level</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DISCRETE_INT       0x00010000  <span class="comment">// Interrupt for individual pin</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>中断触发方式是啥？</p>
<p>就是怎样触发这个中断</p>
<p>主要有两种方式</p>
<p>沿触发和电平触发</p>
<p>沿触发比如说时钟中断，在被响应并被清除时，就不会触发，</p>
<p>电平触发比如串口中断，在被响应并清除后，从中断态返回SVC态仍可能会触发中断。</p>
<p>可能顾名思义就可以吧。。</p>
</blockquote>
<h4 id="（2）void-GPIOIntRegister-uint32-t-ui32Port-void-pfnIntHandler-void"><a href="#（2）void-GPIOIntRegister-uint32-t-ui32Port-void-pfnIntHandler-void" class="headerlink" title="（2）void GPIOIntRegister(uint32_t ui32Port, void (*pfnIntHandler)(void))"></a>（2）void GPIOIntRegister(uint32_t ui32Port, void (*pfnIntHandler)(void))</h4><ol>
<li>功能：注册GPIO中断的中断处理程序</li>
<li>参数:<br>（1）ui32Port ：GPIO口的基地址<br>（2）pfnIntHandler： 是GPIO中断服务程序入口地址指针。</li>
<li>说明：<br>（1）不管是什么外设触发的中断，都要<strong>先注册中断服务函数</strong>，告诉程序中断发生时去哪里，类似的函数有<code>SysCtlIntRegister</code>、<code>ADCIntRegister</code>等<br>（2）如果不利用这些中断注册函数，也可以在启动文件中修改中断向量表进行手动注册<br>（3）GPIOIntRegister只能<strong>以GPIO组为单位注册，不能精确到判断哪个引脚发生中断</strong>，因此要在中断服务函数中判断触发中断的引脚，以下为一个示例</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GPIOF中断服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_interrupt</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">//获取中断状态</span></span><br><span class="line">	<span class="keyword">uint32_t</span> s = GPIOIntStatus(GPIO_PORTF_BASE, <span class="literal">true</span>);</span><br><span class="line">	<span class="comment">//如果PF4触发中断</span></span><br><span class="line">			<span class="keyword">if</span>((s&amp;GPIO_PIN_4) == GPIO_PIN_4)</span><br><span class="line">	&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（3）void-GPIOIntEnable-uint32-t-ui32Port-uint32-t-ui32IntFlags"><a href="#（3）void-GPIOIntEnable-uint32-t-ui32Port-uint32-t-ui32IntFlags" class="headerlink" title="（3）void GPIOIntEnable(uint32_t ui32Port, uint32_t ui32IntFlags)"></a>（3）void GPIOIntEnable(uint32_t ui32Port, uint32_t ui32IntFlags)</h4><ol>
<li>功能：使能<strong>指定引脚</strong>的中断.</li>
<li>参数:<br>（1）ui32Port ：GPIO口的基地址<br>（2）ui32IntFlags： 被禁止的中断源中断屏蔽位(指示哪些引脚中断被开启，是以下参数的逻辑或)</li>
</ol>
<h4 id="（4）void-IntEnable-uint32-t-ui32Interrupt"><a href="#（4）void-IntEnable-uint32-t-ui32Interrupt" class="headerlink" title="（4）void IntEnable(uint32_t ui32Interrupt)"></a>（4）void IntEnable(uint32_t ui32Interrupt)</h4><ol>
<li>功能：使能一个中断</li>
<li>参数:<br>（1）ui32Interrupt 指定的被允许的中断.</li>
<li>说明：这个函数是<strong>中断控制器级</strong>的中断使能控制</li>
</ol>
<h4 id="（5）bool-IntMasterEnable-void"><a href="#（5）bool-IntMasterEnable-void" class="headerlink" title="（5）bool IntMasterEnable(void)"></a>（5）bool IntMasterEnable(void)</h4><ol>
<li>功能：使能处理器中断.</li>
<li>参数：无</li>
<li>说明：<br>（1）这是<strong>处理器级</strong>的中断使能控制，它决定处理器要不要处理中断控制器的请求<br>（2）以上三个函数，从低级到高级对应了中断处理通路的三道“开关”，如下图所示</li>
<li><img src="https://img-blog.csdnimg.cn/20190709124218959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="20190709124218959.png (767×468) (csdnimg.cn)"></li>
</ol>
<h5 id="看来要同时有三个级别的中断使能控制。"><a href="#看来要同时有三个级别的中断使能控制。" class="headerlink" title="看来要同时有三个级别的中断使能控制。"></a>看来要同时有三个级别的中断使能控制。</h5><h4 id="（6）uint32-t-GPIOIntStatus-uint32-t-ui32Port-bool-bMasked"><a href="#（6）uint32-t-GPIOIntStatus-uint32-t-ui32Port-bool-bMasked" class="headerlink" title="（6）uint32_t GPIOIntStatus(uint32_t ui32Port, bool bMasked)"></a>（6）uint32_t GPIOIntStatus(uint32_t ui32Port, bool bMasked)</h4><ol>
<li>功能：读取指定GPIO口的中断状态</li>
<li>参数：<br>（1）ui32Port： GPIO口的基地址.<br>（2）bMasked： 指定返回屏蔽的中断状态还是原始的中断状态</li>
<li>说明： 如果bMasked被设置为真，则函数返回被屏蔽的中断状态，否则返回原始的中断状态。解释一下所谓“<strong>被屏蔽的中断状态</strong>”。在<code>GPIOIntEnable</code>这个函数中，没有写在第二个参数<code>ui32IntFlags</code>中的引脚是被屏蔽的（即<strong>不处理它们的中断事件</strong>）。当bMasked为真时，返回GPIOMIS寄存器值，所有被屏蔽的位都是0，否则返回GPIORIS寄存器值，被屏蔽的位也可能是1（因为虽然不处理这些引脚的中断事件，但它们的输入也可能符合中断特征）</li>
<li>就是输出都那个口在中断状态。</li>
</ol>
<h4 id="（7）void-GPIOIntClear-uint32-t-ui32Port-uint32-t-ui32IntFlags"><a href="#（7）void-GPIOIntClear-uint32-t-ui32Port-uint32-t-ui32IntFlags" class="headerlink" title="（7）void GPIOIntClear(uint32_t ui32Port, uint32_t ui32IntFlags)"></a>（7）void GPIOIntClear(uint32_t ui32Port, uint32_t ui32IntFlags)</h4><ol>
<li><p>功能：清除指定中断源标志</p>
</li>
<li><p>参数:<br>（1）ui32Port ：GPIO口的基地址<br>（2）ui32IntFlags ：被清除的中断源中断屏蔽位</p>
</li>
<li><p>发生中断后，对应的中断标志位置1，进入中断服务函数，在服务函数中务必清除中断标志，否则程序将不停地进入中断服务函数</p>
</li>
</ol>
<h2 id="二、例程"><a href="#二、例程" class="headerlink" title="二、例程"></a>二、例程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_INT_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//使能GPIO组，这里设置的是F口</span></span><br><span class="line">   SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line">   <span class="comment">//设置某引脚为输入，这里设置的是PF4</span></span><br><span class="line">   GPIODirModeSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_DIR_MODE_IN);</span><br><span class="line">   <span class="comment">//设置为推挽输入</span></span><br><span class="line">   GPIOPadConfigSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);</span><br><span class="line">   <span class="comment">//配置中断类型为沿下降</span></span><br><span class="line">   GPIOIntTypeSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_FALLING_EDGE);</span><br><span class="line">   <span class="comment">//注册中断函数</span></span><br><span class="line">   GPIOIntRegister(GPIO_PORTF_BASE, io_interrupt);</span><br><span class="line">   <span class="comment">//开启中断</span></span><br><span class="line">   GPIOIntEnable(GPIO_PORTF_BASE, GPIO_PIN_4);</span><br><span class="line">   IntEnable(INT_GPIOF);</span><br><span class="line">   IntMasterEnable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是中断函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_interrupt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//中断函数一开始要清除发生的中断标志</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s=GPIOIntStatus(GPIO_PORTF_BASE,<span class="literal">true</span>);</span><br><span class="line">    GPIOIntClear(GPIO_PORTF_BASE, s);</span><br><span class="line">    <span class="comment">//然后判断读取到的是不是设置的引脚</span></span><br><span class="line">    <span class="keyword">if</span>((s&amp;GPIO_PIN_4)==GPIO_PIN_4)<span class="comment">//如果读取到的是PF4</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4));<span class="comment">//等待按键松开</span></span><br><span class="line">        do_something();<span class="comment">//做想做的事情</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/GPIO_interrupt/" data-id="ckmm8nzw3000rsk3d3pw10lz2" data-title="GPIO中断" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Interrupt Controller(NVIC)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/Interrupt%20Controller(NVIC)/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/Interrupt%20Controller(NVIC)/">中断控制器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Interrupt-Controller-NVIC"><a href="#Interrupt-Controller-NVIC" class="headerlink" title="Interrupt Controller(NVIC)"></a>Interrupt Controller(NVIC)</h1><p>The interrupt controller API provides a set of functions for dealing with the Nested Vectored Interrupt<br>Controller (NVIC). Functions are provided to enable and disable interrupts, register interrupt<br>handlers, and set the priority of interrupts.</p>
<blockquote>
<p>中断控制器API提供了一系列与内置向量式中断控制器有关的函数，这些函数能使能/使不能中断，注册中断，设置中断优先级等</p>
</blockquote>
<p>The NVIC provides global interrupt masking, prioritization, and handler dispatching. Devices within<br>the Tiva family support up to 154 interrupt sources and eight priority levels. Individual interrupt<br>sources can be masked, and the processor interrupt can be globally masked as well (without affecting<br>the individual source masks).</p>
<blockquote>
<p>NVIC提供了全局中断屏蔽，优先级和处理器调度功能，在Tiva系列设备里至多支持154个中断和8个中断级，单个中断源可以被屏蔽，处理器屏蔽也可以被全局屏蔽（不影响单个中断源的屏蔽哦）</p>
</blockquote>
<p>The NVIC is tightly coupled with the Cortex-M microprocessor. When the processor responds to<br>an interrupt, the NVIC supplies the address of the function to handle the interrupt directly to the<br>processor. This action eliminates the need for a global interrupt handler that queries the interrupt<br>controller to determine the cause of the interrupt and branch to the appropriate handler, reducing<br>interrupt response time.</p>
<blockquote>
<p>NVIC紧密搭配着cortex_M微处理器。当处理器对中断作出反应时，NVIC直接把处理中断的函数的地址提供给处理器，此操作无需使用全局中断处理程序来查询中断控制器以确定中断的原因，并分支到相应的处理程序，从而减少中断响应时间。  </p>
</blockquote>
<p>The interrupt prioritization in the NVIC allows higher priority interrupts to be handled before lower<br>priority interrupts, as well as allowing preemption of lower priority interrupt handlers by higher priority<br>interrupts. Again, this helps reduce interrupt response time (for example, a 1 ms system control<br>interrupt is not held off by the execution of a lower priority 1 second housekeeping interrupt handler).</p>
<blockquote>
<p>中断处理优先级使得高优先级的中断在低优先级中断之前处理，并允许高优先级中断抢占低优先级中断。这还能减少中断响应时间，比如1ms的系统控制中断不会被更低优先级的1ms中断所延迟。</p>
</blockquote>
<p>Sub-prioritization is also possible; instead of having N bits of preemptable prioritization, the NVIC<br>can be configured (via software) for N - M bits of preemptable prioritization and M bits of sub-priority.<br>In this scheme, two interrupts with the same preemptable prioritization but different sub-priorities<br>do not cause a preemption; tail chaining is used instead to process the two interrupts back-to-back.</p>
<blockquote>
<p>还可以设置子优先级，如果不设置N位可抢占优先级的话，可以通过软件设置N-M个可抢占优先级和M个子优先级，在这种方案下，两个仅仅子优先级不同的可抢占中断不会导致抢占，单片机会使用尾链来来回处理两个中断</p>
</blockquote>
<p>If two interrupts with the same priority (and sub-priority if so configured) are asserted at the same<br>time, the one with the lower interrupt number is processed first. The NVIC keeps track of the nesting<br>of interrupt handlers, allowing the processor to return from interrupt context only once all nested<br>and pending interrupts have been handled.</p>
<blockquote>
<p>如果两个中断有相同的优先级（和子优先级）还被同时触发了，中断数更低的有限执行，NVIC会跟踪中断处理程序的嵌套，要求处理器在处理完所有被嵌套和挂起的中断后再返回</p>
</blockquote>
<p>Interrupt handlers can be configured in one of two ways; statically at compile time or dynamically at<br>run time. Static configuration of interrupt handlers is accomplished by editing the interrupt handler<br>table in the application’s startup code. When statically configured, the interrupts must be explicitly<br>enabled in the NVIC via IntEnable() before the processor can respond to the interrupt (in addition to<br>any interrupt enabling required within the peripheral itself). Statically configuring the interrupt table<br>provides the fastest interrupt response time because the stacking operation (a write to SRAM) can<br>be performed in parallel with the interrupt handler table fetch (a read from Flash), as well as the<br>prefetch of the interrupt handler itself (assuming it is also in Flash).</p>
<blockquote>
<p>中断处理程序可以用两种方式中的一种来设置，编译时设置或者运行时动态设置。静态配置使用的是IntEnable（）函数完成的，运行的时候静态配置的中断处理程序更快一点。</p>
</blockquote>
<p>Alternatively, interrupts can be configured at run-time using IntRegister() (or the analog in each<br>individual driver). When using IntRegister(), the interrupt must also be enabled as before; when<br>using the analogue in each individual driver, IntEnable() is called by the driver and does not need<br>to be called by the application. Run-time configuration of interrupts adds a small latency to the<br>interrupt response time because the stacking operation (a write to SRAM) and the interrupt handler<br>table fetch (a read from SRAM) must be performed sequentially.</p>
<blockquote>
<p>在运行时设置的话，需要用到IntRegister()函数，会有延迟。</p>
</blockquote>
<p>Run-time configuration of interrupt handlers requires that the interrupt handler table be placed on a<br>1-kB boundary in SRAM (typically this is at the beginning of SRAM). Failure to do so results in an<br>incorrect vector address being fetched in response to an interrupt. The vector table is in a section<br>called “vtable” and must be placed appropriately with a linker script.</p>
<blockquote>
<p>中断处理程序的配置需要将中断处理表放在SARM1kb的边缘上。。。。。</p>
</blockquote>
<p>This driver is contained in driverlib/interrupt.c, with driverlib/interrupt.h containing<br>the API declarations for use by applications.</p>
<p>他的函数非常少</p>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212164149113.png" alt="image-20201212164149113"></p>
<p>前两个是使能/使不能一个中断</p>
<p>第三个 确认一个中断是否在运行，如果一个中断在运行的话，会返回一个非零数</p>
<p>第四个 第五个 使能/使不能处理器中断</p>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212164210385.png" alt="image-20201212164210385"></p>
<p>第一个 第二个 挂起/放下一个中断</p>
<p>第三个 获取一个中断的优先级</p>
<p>第四个 获取中断控制器的优先级分组 就是返回可抢占优先级的位数</p>
<p>第五个 设置可抢占优先级的位数</p>
<p>第六个 获取优先级屏蔽 </p>
<blockquote>
<p>This function gets the current setting of the interrupt priority masking level. The value returned is the priority level such that all interrupts of that and lesser priority are masked. A value of 0 means that priority masking is disabled.<br>Smaller numbers correspond to higher interrupt priorities. So for example a priority level mask of 4 allows interrupts of priority level 0-3, and interrupts with a numerical priority of 4 and greater are blocked.<br>The hardware priority mechanism only looks at the upper 3 bits of the priority level, so any prioritization must be performed in those bits.</p>
</blockquote>
<p>第七个 设置优先级屏蔽</p>
<p>第八个 设置中断优先级</p>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212165114559.png" alt="image-20201212165114559"></p>
<p>第一个 注册一个函数，中断发生是就调用它</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// UART 0 interrupt handler.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">UART0Handler(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Handle interrupt.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the UART 0 interrupt handler.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">IntRegister(INT_UART0, UART0Handler);</span><br></pre></td></tr></table></figure>
<p>第二个 触发一个中断 （直接触发）</p>
</blockquote>
<p>第三个 解注册一个中断</p>
<p>所以怎样使用中断呢？</p>
<p>直接去对应外设那里去查询中断怎样使用，然后回来使能中断即可，有需要就设置优先级啊，子优先级啊，屏蔽啊等等。</p>
<p>有需要还可以直接触发一个中断的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/Interrupt%20Controller(NVIC)/" data-id="ckmm8nzw3000tsk3d2m79311p" data-title="中断控制器" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MIDI文件格式分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/MIDI%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/MIDI%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/">midi</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MIDI文件格式分析"><a href="#MIDI文件格式分析" class="headerlink" title="MIDI文件格式分析"></a>MIDI文件格式分析</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiankong_/article/details/78754545?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">感谢这个博客</a></p>
<h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><p>每一个MIDI文件的开头都有如下一段内容，4d 54 68 64 00 00 00 06 ff ff nn nn dd dd</p>
<p>前四个字节是ASCII字符MThd 表示这是一个Midi文件，</p>
<p>下面四个字节是指明文件头描述部分的字节数，一共是6，所以一定是00 00 00 06</p>
<p>下面是剩余部分的含义</p>
<p>ff ff指定Midi的格式</p>
<blockquote>
<p>00 00 表示单音轨</p>
<p>00 01表示多音轨同步（常见）</p>
<p>00 02表示多音轨不同步</p>
</blockquote>
<p>nn nn表示轨道数</p>
<blockquote>
<p>实际音轨倒数加上一个全局的音轨</p>
</blockquote>
<p>dd dd指定基本时间</p>
<blockquote>
<p>一般为120 （00 78）即一个四分音符的tick数，tick是MIDI中最小时间单位</p>
</blockquote>
<p>例如下面</p>
<blockquote>
<p>4d54 6864 0000 0006 0001 0003 01e0</p>
<p>表示这是一个MIDI文件 文件头描述部分占6字节 多音轨同步 一共3个音轨 基本时间是01e0（480）</p>
</blockquote>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>先来看全局音轨 全局音轨包括了歌曲的附加信息（比如标题和版权），歌曲速度和系统码等内容。</p>
<p>不论是全局音轨还是含有字符的音轨，都以4D 54 72 6B开头，表示”MTrk”后面跟着一个四个字节的整数，表示该音轨的字节数（不包括MTrk和本身的四个字节），然后是记录数据的地方。</p>
<p>每一个数据都有相同的结构：时间差+事件。</p>
<h5 id="时间差"><a href="#时间差" class="headerlink" title="时间差"></a>时间差</h5><p>所谓时间差，就是指从前一个事件到这个事件的时间数，单位是tick。一个字节有 8 位,如果仅使用 7 位,它可以表示 0~127 这 128 个数,而剩下的一位,则用来作为标志。(这一位被放在了每个字节的最前端）。如果要表示的数在以上范围,则这个标志为 0,这时,一个7 位的字节可以表示 0~127tick。如果要表示的数 超出了这个范围(比如 240),则把标志设置成 1,然后记录下高 7 位,剩下的留给下一个字节,在该例中 240 可以分解成 128<em> 1+112,这里的 1 就是第一个字节要记录的,加上标志位,应该为 10000001,即十六进制的 81;而 112 是下一个字节记录的,它的十六进制为 70:所以要表示 240 这个时间,要写成 81 70。 同理,如果要表示 65535tick,则可以先计算出65535=1282</em>3+1281<em>127+1280</em>127,然后得出结果:83 FF 7F。 由此,我们反过来也可以知道如何确定时间差:只要标志位为 0,则表示结束读取时间差。比如 82 C0 03 表示 1282<em>2+1281</em>64+1280*3=40963,如果基本时间为 120,则有 341:043 个四分音符。</p>
<p>以这种方式记录整数的字节称为动态字节,它根据记录的整数改变自身的长度,这在后面还要用到,所以 必须熟练计算。</p>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p>事件可以分为音符，控制器系统信息等几个种类，对于这些事件，都有统一的表达结构：种类+参数</p>
<p>对于一个音符，由于他的有效范围是0~127，所以直接用00~7F作为种类，也可以认为是个音符，比如3C表示中央C，而一个音符的最重要的参数是力度，比如，3C 64表示一个力度为100的中央C音符。</p>
<p>因为一个字节有8位，所以第一位如果置1，那么它就可以表示其他信息，</p>
<p>下表中,x 表示音轨 0~F,比如 81 表示松开第二轨的音符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>种类</th>
<th>参数(十六进制)</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>字节</td>
<td>含义</td>
<td></td>
</tr>
<tr>
<td>8x</td>
<td>松开音符</td>
<td>音符(00~7F):松开的音符</td>
</tr>
<tr>
<td>力度:00~7F</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9x</td>
<td>按下音符</td>
<td>音符(00~7F):按下的音符</td>
</tr>
<tr>
<td>力度:00~7F</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Ax</td>
<td>触后音符 (Key After Touch)</td>
<td>音符:00~7F</td>
</tr>
<tr>
<td>力度:00~7F</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Bx</td>
<td>控制器</td>
<td>控制器号码:00~7F</td>
</tr>
<tr>
<td>控制器参数:00~7F</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cx</td>
<td>改变乐器</td>
<td>乐器号码:00~7F</td>
</tr>
<tr>
<td>Dx</td>
<td>触后通道</td>
<td>值:00~7F</td>
</tr>
<tr>
<td>Ex</td>
<td>滑音</td>
<td>音高(Pitch)低位:Pitch mod 128</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>音高高位:Pitch div 128</th>
</tr>
</thead>
<tbody>
<tr>
<td>F0</td>
<td>系统码</td>
<td>系统码字节数:动态字节</td>
</tr>
<tr>
<td>系统码:不含开头的 F0,但包括结尾的 F7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FF</td>
<td>其他格式</td>
<td>程式种类:00~FF</td>
</tr>
<tr>
<td>数据占用的字节数:动态字节</td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据:个数由上一参数确定</td>
<td></td>
<td></td>
</tr>
<tr>
<td>00~7F</td>
<td>上次激活格式的参数(8x、9x、Ax、Bx、Cx、Dx、Ex)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>节拍器时钟</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>一个四分音符包含的三十二分音符的个数</td>
</tr>
<tr>
<td>59</td>
<td>调号</td>
<td>02</td>
<td>升降号数:-7~-1(降号),0(C),1~7(升号)</td>
</tr>
<tr>
<td>大小调:0(大调),1(小调)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7F</td>
<td>音序特定信息</td>
<td>—</td>
<td>音序特定信息</td>
</tr>
</tbody>
</table>
</div>
<p>下表详细地列出了 FF 的详细情况,对于字节数由数据决定的情况,表中以“—”表示。</p>
<p>种类 字 节</p>
<p>字节 含义<br>00 设置轨道音序</p>
<p>数据 数</p>
<p>02 音序号 00 00~ FF FF</p>
<p>01</p>
<p>歌曲备注 文本信息 —</p>
<p>音轨文本 文本信息</p>
<p>02 歌曲版权<br>歌曲标题 —</p>
<p>03</p>
<p>— 版权信息</p>
<p>歌曲标题:用于全局音轨,第一次使用表示主标题,第二次表 示副标题</p>
<p>音轨名称 — 音轨名</p>
<p>04 乐器名称</p>
<p>— 音轨文本(同 01/2)</p>
<p>05歌词 —歌词</p>
<p>06  标记</p>
<p>07  开始点</p>
<p>2F 音轨结束标志</p>
<p>51 速度</p>
<p>— 用文本标记(Marker)</p>
<p>— 用文本记录开始点(同 01/2)</p>
<p>00 无</p>
<p>03 3字节整数,1个四分音符的微秒数</p>
<p>58节拍 04分子</p>
<p>分母:00(1),01(2),02(4),03(8)等</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>节拍器时钟</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td>一个四分音符包含的三十二分音符的个数</td>
</tr>
<tr>
<td>59</td>
<td>调号</td>
<td>02</td>
<td>升降号数:-7~-1(降号),0(C),1~7(升号)</td>
</tr>
<tr>
<td>大小调:0(大调),1(小调)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7F</td>
<td>音序特定信息</td>
<td>—</td>
<td>音序特定信息</td>
</tr>
</tbody>
</table>
</div>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/MIDI%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/" data-id="ckmm8nzw4000vsk3dgvvn9izn" data-title="midi" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/midi/" rel="tag">midi</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Pulse Width Modulator" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/Pulse%20Width%20Modulator/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/Pulse%20Width%20Modulator/">PWM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Each instance of a Tiva PWM module provides up to four instances of a PWM generator block, and an output control block. Each generator block has two PWM output signals, which can be operated independently or as a pair of signals with dead band delays inserted. Each generator block also has an interrupt output and a trigger output. The control block determines the polarity of the PWM signals and which signals are passed through to the pins.</p>
<blockquote>
<p>每个PWM提供了最多4个PWM发生器和一个输出控制模块，每一个发生器能产生两个PWM输出信号，可以独立操作，也可以作为一对插入了死区延迟的信号运行。每一个生成器块还有一个中断输出和一个触发输出，控制块确定PWM信号的极性以及哪些信号传递到引脚。</p>
</blockquote>
<p>Some of the features of the Tiva PWM module are:<br>Up to four generator blocks, each containing<br>• One 16-bit down or up/down counter<br>• Two comparators<br>• PWM generator<br>• Dead band generator</p>
<blockquote>
<p>至多4个产生模块，每一个产生模块包括</p>
<blockquote>
<p>一个十六位的向上/向下计数器</p>
<p>两个比较器</p>
<p>PWM产生器</p>
<p>死区产生器</p>
</blockquote>
</blockquote>
<p>Control block<br>• PWM output enable<br>• Output polarity control<br>• Synchronization<br>• Fault handling<br>• Interrupt status</p>
<blockquote>
<p>控制模块有</p>
<blockquote>
<p>PWM输出使能</p>
<p>输出极性控制</p>
<p>错误处理</p>
<p>中断状态</p>
</blockquote>
</blockquote>
<p>This driver is contained in driverlib/pwm.c, with driverlib/pwm.h containing the API declarations for use by applications.</p>
<h2 id="细节描述"><a href="#细节描述" class="headerlink" title="细节描述"></a>细节描述</h2><p>These functions perform high-level operations on PWM modules.</p>
<blockquote>
<p>这些模块表现了高水平的对PWM的操作</p>
</blockquote>
<p>The following functions provide the user with a way to configure the PWM for the most common operations, such as setting the period, generating left- and center-aligned pulses, modifying the pulse width, and controlling interrupts, triggers, and output characteristics. However, the PWM module is very versatile and can be configured in a number of different ways, many of which are beyond the scope of this API. In order to fully exploit the many features of the PWM module, users are advised to use register access macros.</p>
<blockquote>
<p>接下来的函数为用户提供了一种配置PWM做最普通操作的方式，这些操作有设定周期，产生左对齐/中心对齐的脉冲，调节脉冲宽度，控制中断/触发/输出特征等功能。然而，PWM模块非常的强大，可以用很多种方式设置，许多用的都不是这些API。为了能充分利用PWM模块的诸多功能，我们推荐用户使用寄存器。</p>
</blockquote>
<p>When discussing the various components of a PWM module, this API uses the following labeling convention:</p>
<p>The generator blocks are called Gen0, Gen1, Gen2 and Gen3.</p>
<blockquote>
<p>产生器模块被称为Gen0, Gen1, Gen2 and Gen3.</p>
</blockquote>
<p>The two PWM output signals associated with each generator block are called OutA and OutB.</p>
<blockquote>
<p>与产生器模块相关的两个PWM输出信号被称为OutA和OutB</p>
</blockquote>
<p>The output signals are called PWM0, PWM1, PWM2, PWM3, PWM4, PWM5, PWM6 and PWM7.</p>
<blockquote>
<p>输出信号被称为PWM0, PWM1, PWM2, PWM3, PWM4, PWM5, PWM6 and PWM7.</p>
</blockquote>
<p>PWM0 and PWM1 are associated with Gen0, PWM2 and PWM3 are associated with Gen1, PWM4 and PWM5 are associated with Gen2 and PWM6 and PWM7 are associated with Gen3.</p>
<blockquote>
<p>PWM0和PWM1与Gen0相关联，PWM2和PWM3与Gen1相关联，PWM4和PWM5与Gen2相关联，PWM6和PWM7与Gen3相关联。</p>
</blockquote>
<p>Also, as a simplifying assumption for this API, comparator A for each generator block is used exclusively to adjust the pulse width of the even numbered PWM outputs (PWM0, PWM2, PWM4 and PWM6). In addition, comparator B is used exclusively for the odd numbered PWM outputs (PWM1, PWM3, PWM5 and PWM7).<br>Note that the number of generators and PWM outputs supported varies depending upon the Tiva part in use. Please consult the datasheet for the part you are using to determine whether it supports 1 or 2 modules with 3 or 4 generators each and 6 or 8 outputs each. </p>
<blockquote>
<p>另外，作为对此API的简化假设，每个生成器模块的比较器仅用于调整偶数个PWM输出的脉冲高度，比较器A仅用于计数PWM输出</p>
<p>请注意，支持的生成器和 PWM 输出的数量因使用的 Tiva 部件而异。请参阅您使用的部件的数据表，以确定它是否支持 1 个或 2 个模块，每个模块有 3 个或 4 个生成器，每个模块有 6 个或 8 个输出。</p>
</blockquote>
<p><strong>我们这款单片机包括两个PWM模块，总共有16个输出</strong></p>
<p>这次我们直接看例程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Enable the PWM0 peripheral</span></span><br><span class="line"><span class="comment">// 使能PWM外设</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM0);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Wait for the PWM0 module to be ready.</span></span><br><span class="line"><span class="comment">// 等待PWM模块准备好</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span>(!SysCtlPeripheralReady(SYSCTL_PERIPH_PWM0))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Configure the PWM generator for count down mode with immediate updates</span></span><br><span class="line"><span class="comment">// to the parameters.</span></span><br><span class="line"><span class="comment">// 配置PWM产生器，并设置器为向下计数模式，和非同步模式</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMGenConfigure(PWM_BASE, PWM_GEN_0,PWM_GEN_MODE_DOWN | PWM_GEN_MODE_NO_SYNC);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the period. For a 50 KHz frequency, the period = 1/50,000, or 20</span></span><br><span class="line"><span class="comment">// microseconds. For a 20 MHz clock, this translates to 400 clock ticks.</span></span><br><span class="line"><span class="comment">// Use this value to set the period.</span></span><br><span class="line"><span class="comment">// 设置周期。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMGenPeriodSet(PWM_BASE, PWM_GEN_0, <span class="number">400</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the pulse width of PWM0 for a 25% duty cycle.</span></span><br><span class="line"><span class="comment">// 脉冲宽度设置</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMPulseWidthSet(PWM_BASE, PWM_OUT_0, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the pulse width of PWM1 for a 75% duty cycle.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMPulseWidthSet(PWM_BASE, PWM_OUT_1, <span class="number">300</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Start the timers in generator 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMGenEnable(PWM_BASE, PWM_GEN_0);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Enable the outputs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMOutputState(PWM_BASE, (PWM_OUT_0_BIT | PWM_OUT_1_BIT), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h2 id="关注如下函数"><a href="#关注如下函数" class="headerlink" title="关注如下函数"></a>关注如下函数</h2><h4 id="PWMGenConfigure"><a href="#PWMGenConfigure" class="headerlink" title="PWMGenConfigure"></a>PWMGenConfigure</h4><p>用于配置PWM</p>
<p>This function is used to set the mode of operation for a PWM generator. The counting mode, synchronization mode, and debug behavior are all configured. After configuration, the generator is left in the disabled state.</p>
<blockquote>
<p>这个函数用于设置PWM产生器的操作模式。计数模式，同步模式，调试模式都在这里设置。设置之后，产生器处于关闭状态。</p>
</blockquote>
<p>A PWM generator can count in two different modes: count down mode or count up/down mode. In count down mode, it counts from a value down to zero, and then resets to the preset value, producing left-aligned PWM signals (that is, the rising edge of the two PWM signals produced by the generator occur at the same time). In count up/down mode, it counts up from zero to the preset value, counts back down to zero, and then repeats the process, producing centeraligned PWM signals (that is, the middle of the high/low period of the PWM signals produced by the generator occurs at the same time).</p>
<blockquote>
<p>PWM产生器可以用两种计数模式计数，向下计数模式和向上/向下计数模式。</p>
<p>在向下计数模式中，它从一个值向下数到零，然后恢复到预设值，产生一个左对齐的PWM信号（也就是说，两个产生器产生的信号的升边同时出现）在向上向下计数模式中，它从零数到预设值，再数回到零，反复这个过程，产生的是中心对齐的PWM信号（也就是说，产生器产生的PWM信号的周期的中间时刻是同时发生的）<strong>每个生成器不是能产生两个PWM信号嘛</strong></p>
</blockquote>
<p>When the PWM generator parameters (period and pulse width) are modified, their effect on the output PWM signals can be delayed. In synchronous mode, the parameter updates are not applied until a synchronization event occurs. This mode allows multiple parameters to be modified and take effect simultaneously, instead of one at a time. Additionally, parameters to multiple PWM generators in synchronous mode can be updated simultaneously, allowing them to be treated as if they were a unified generator. In non-synchronous mode, the parameter updates are not delayed until a synchronization event. In either mode, the parameter updates only occur when the counter is at zero to help prevent oddly formed PWM signals during the update (that is, a PWM pulse that is too short or too long).</p>
<blockquote>
<p>当PWM脉冲产生器的参数（周期和脉冲宽度）被修改时，它们对PWM信号的影响可能会延迟。</p>
<p>在同步模式下，直到发生同步时间时应用参数才被更新。此模式允许多个参数同时修改并生效，而不是一次一个参数。此外，同步模式下多个 PWM 生成器的参数可以同时更新，从而可以将它们视为统一生成器。</p>
<p>在非同步模式下，参数 更新不会延迟到同步事件，在任意模式下，参数更新仅在计数器为零时在会发生，用以防止更新期间产生奇怪的PWM信号。</p>
</blockquote>
<p>The PWM generator can either pause or continue running when the processor is stopped via the debugger. If configured to pause, it continues to count until it reaches zero, at which point it pauses until the processor is restarted. If configured to continue running, it keeps counting as if nothing had happened.</p>
<blockquote>
<p>当调试器使处理器停止时，PWM产生器可以停止/继续运行如果配置为暂停，则它将继续计数，直到达到零，此时它会暂停，直到重新启动处理器。如果配置为继续运行，则继续计数，就像什么都没发生一样。</p>
</blockquote>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212211525865.png" alt="image-20201212211525865"></p>
<p>这是这个函数的参数，第一部分是PWM模块的基址，第二部分是PWM产生器，究竟是GEN几，最后是配置参数。</p>
<p>那么有哪些参数呢？</p>
<p>PWM_GEN_MODE_DOWN or PWM_GEN_MODE_UP_DOWN to specify the counting<br>mode</p>
<p><strong>计数模式，就是向上模式还是向上向下模式</strong></p>
<p>PWM_GEN_MODE_SYNC or PWM_GEN_MODE_NO_SYNC to specify the counter load<br>and comparator update synchronization mode</p>
<p><strong>不晓得</strong></p>
<p>PWM_GEN_MODE_DBG_RUN or PWM_GEN_MODE_DBG_STOP to specify the debug<br>behavior</p>
<p><strong>配置了debug的行为</strong></p>
<p>PWM_GEN_MODE_GEN_NO_SYNC, PWM_GEN_MODE_GEN_SYNC_LOCAL, or<br>PWM_GEN_MODE_GEN_SYNC_GLOBAL to specify the update synchronization mode<br>for generator counting mode changes</p>
<p><strong>不晓得</strong></p>
<p>PWM_GEN_MODE_DB_NO_SYNC, PWM_GEN_MODE_DB_SYNC_LOCAL, or<br>PWM_GEN_MODE_DB_SYNC_GLOBAL to specify the deadband parameter synchronization<br>mode</p>
<p><strong>指定死区参数同步模式</strong></p>
<p>PWM_GEN_MODE_FAULT_LATCHED or PWM_GEN_MODE_FAULT_UNLATCHED to<br>specify whether fault conditions are latched or not</p>
<p><strong>指定是否锁定故障条件</strong></p>
<p>PWM_GEN_MODE_FAULT_MINPER or PWM_GEN_MODE_FAULT_NO_MINPER to<br>specify whether minimum fault period support is required</p>
<p><strong>确定是否需要最小错误周期支持</strong></p>
<p>PWM_GEN_MODE_FAULT_EXT or PWM_GEN_MODE_FAULT_LEGACY to specify<br>whether extended fault source selection support is enabled or not</p>
<p><strong>指定是否启用扩展故障源选择支持</strong></p>
<!--死区就是中性区或者是不作用区-->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/Pulse%20Width%20Modulator/" data-id="ckmm8nzw5000xsk3dczpt51ts" data-title="PWM" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-System Tick" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/System%20Tick/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/System%20Tick/">SysTick</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SysTick"><a href="#SysTick" class="headerlink" title="SysTick"></a>SysTick</h1><p>SysTick is a simple timer that is part of the NVIC controller in the Cortex-M microprocessor. Its<br>intended purpose is to provide a periodic interrupt for an RTOS, but it can be used for other simple<br>timing purposes.<br>The SysTick interrupt handler does not need to clear the SysTick interrupt source as it is cleared<br>automatically by the NVIC when the SysTick interrupt handler is called.<br>This driver is contained in driverlib/systick.c, with driverlib/systick.h containing the<br>API declarations for use by applications.</p>
<p>大概的翻译一下</p>
<p>SysTick是一个简单的定时器，是Cortex-M微处理器中NVIXC控制器的一部分。他的目的在于为RTOS提供一个周期性的中断，也可以被用于其他简单的计时目的。</p>
<p>Systick 中断处理不需要清除Sys tick中断源，当SysTick中断处理被调用时NVIC会自动清理中断源。</p>
<p>头文件是driverlib/systick.h</p>
<p>The SysTick API is fairly simple, like SysTick itself. There are functions for configuring and enabling<br>SysTick (SysTickEnable(), SysTickDisable(), SysTickPeriodSet(), SysTickPeriodGet(), and<br>SysTickValueGet()) and functions for dealing with an interrupt handler for SysTick (SysTickIntRegister(),<br>SysTickIntUnregister(), SysTickIntEnable(), and SysTickIntDisable()).</p>
<p>他所包含的函数也特别少</p>
<p>主要有设置和使能函数还有处理中断的函数</p>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212171840774.png" alt="image-20201212171840774"></p>
<p>设置和使能的函数有</p>
<p>(SysTickEnable(), SysTickDisable(), SysTickPeriodSet(), SysTickPeriodGet(), and<br>SysTickValueGet())</p>
<p>先看头两个SysTickEnable(), SysTickDisable(), 使能和停止SysTick</p>
<p>如果中断处理已经注册，那就等中断重启时再停止。</p>
<p>其中SysTickEnable还有个note</p>
<blockquote>
<p>Calling this function causes the SysTick counter to (re)commence counting from its current<br>value. The counter is not automatically reloaded with the period as specified in a previous call<br>to SysTickPeriodSet(). If an immediate reload is required, the NVIC_ST_CURRENT register<br>must be written to force the reload. Any write to this register clears the SysTick counter to 0<br>and causes a reload with the supplied period on the next clock.</p>
</blockquote>
<p>上面是使能定时器的函数，接下来是使能定时器中断的函数SysTickIntEnable(), and SysTickIntDisable()</p>
<p>然后时注册/去除注册的函数SysTickIntRegister(),SysTickIntUnregister(),</p>
<p>其中SysTickIntRegister(),的参数是一个函数指针，表示中断发生时要调用的函数</p>
<p>还有两个函数能设置/返回计时器周期</p>
<p>周期可以设置在1到16777216之间，单位是处理器的时钟数</p>
<p>最后一个函数是获取定时器counter的函数SysTickValueGet()</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/System%20Tick/" data-id="ckmm8nzw60010sk3db9loa1as" data-title="SysTick" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-TIMER_CAPTURE" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/TIMER_CAPTURE/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/TIMER_CAPTURE/">Timer Capture</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="TIMER-CAPTURE"><a href="#TIMER-CAPTURE" class="headerlink" title="TIMER_CAPTURE"></a>TIMER_CAPTURE</h1><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>计时器模块可以捕捉io脚的电平边沿，硬件上要求电平保持时间大于两个时钟周期，在这个模式下，技术范围扩展到24/48位</p>
<p>计数值可以为加计数、减计数，加计数的范围是零到预设值，减计数是Preload到预设值。</p>
<p>加计数和减计数的另一个差异是计数终止时的差异，加计数模式下，计数器会自动清零重新计数，减计数模式下，计数器会恢复preload值，但是会停止计数，需要重新使能。</p>
<h3 id="功能一，边沿计数"><a href="#功能一，边沿计数" class="headerlink" title="功能一，边沿计数"></a>功能一，边沿计数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line">    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3);</span><br><span class="line">    GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer2AIntHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ulstatus = TimerIntStatus(TIMER2_BASE, TIMER_CAPA_MATCH | TIMER_CAPB_MATCH);</span><br><span class="line">    TimerIntClear(TIMER2_BASE, ulstatus);</span><br><span class="line">        t++;</span><br><span class="line">        <span class="keyword">if</span>(t%<span class="number">2</span>)&#123;</span><br><span class="line">            GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_ccp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使能GPIO时钟</span></span><br><span class="line">    <span class="comment">//SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span></span><br><span class="line">    <span class="comment">//使能Timer模块</span></span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER2);</span><br><span class="line">    <span class="comment">//配置GPIO引脚为Timer捕捉模式</span></span><br><span class="line">    GPIOPinConfigure(GPIO_PF4_T2CCP0);</span><br><span class="line">    GPIOPinTypeTimer(GPIO_PORTF_BASE, GPIO_PIN_4);</span><br><span class="line">    <span class="comment">//配置管脚为弱上拉模式</span></span><br><span class="line">    GPIOPadConfigSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);</span><br><span class="line">    <span class="comment">//配置Timer的A模块为边沿触发 加计数模式</span></span><br><span class="line">    TimerConfigure(TIMER2_BASE, TIMER_CFG_SPLIT_PAIR | TIMER_CFG_A_CAP_COUNT_UP);</span><br><span class="line">    <span class="comment">//设置下降沿触发</span></span><br><span class="line">    TimerControlEvent(TIMER2_BASE, TIMER_A, TIMER_EVENT_POS_EDGE);</span><br><span class="line">    TimerMatchSet(TIMER2_BASE, TIMER_A, <span class="number">3</span>);</span><br><span class="line">    TimerIntRegister(TIMER2_BASE, TIMER_A, Timer2AIntHandler);</span><br><span class="line">    IntMasterEnable();</span><br><span class="line">    TimerIntEnable(TIMER2_BASE, TIMER_CAPA_MATCH);</span><br><span class="line">    IntEnable(INT_TIMER2A);</span><br><span class="line">    TimerEnable(TIMER2_BASE,TIMER_A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="功能二，边沿计时"><a href="#功能二，边沿计时" class="headerlink" title="功能二，边沿计时"></a>功能二，边沿计时</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer2AIntHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s=TimerIntStatus(TIMER2_BASE,TIMER_CAPA_EVENT);</span><br><span class="line">    TimerIntClear(TIMER2_BASE,s);</span><br><span class="line">    UARTprintf(<span class="string">&quot;Captured Value: 0x%04X\n&quot;</span>, TimerValueGet(TIMER2_BASE, TIMER_A));</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIMER_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使能定时器和GPIO</span></span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER2);</span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line">    <span class="comment">//配置GPIO引脚为timer捕捉模式</span></span><br><span class="line">    GPIOPinConfigure(GPIO_PF4_T2CCP0);</span><br><span class="line">    GPIOPinTypeTimer(GPIO_PORTF_BASE, GPIO_PIN_4);</span><br><span class="line">    <span class="comment">//配置管脚为弱上拉模式</span></span><br><span class="line">    GPIOPadConfigSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);</span><br><span class="line">    <span class="comment">//配置Timer模块为沿触发加计时模式</span></span><br><span class="line">    TimerConfigure(TIMER2_BASE, TIMER_CFG_SPLIT_PAIR | TIMER_CFG_A_CAP_TIME_UP);</span><br><span class="line">    <span class="comment">//使用下降沿触发</span></span><br><span class="line">    TimerControlEvent(TIMER2_BASE, TIMER_A, TIMER_EVENT_NEG_EDGE);</span><br><span class="line">    <span class="comment">//设置计数范围</span></span><br><span class="line">    TimerLoadSet(TIMER2_BASE, TIMER_A, <span class="number">0x8FFF</span>);</span><br><span class="line">    <span class="comment">//注册定时器中断</span></span><br><span class="line">    TimerIntRegister(TIMER2_BASE, TIMER_A, Timer2AIntHandler);</span><br><span class="line">    <span class="comment">//使能中断，定时器，定时器中断</span></span><br><span class="line">    IntMasterEnable();</span><br><span class="line">    TimerIntEnable(TIMER2_BASE, TIMER_CAPA_EVENT);</span><br><span class="line">    IntEnable(INT_TIMER2A);</span><br><span class="line">    TimerEnable(TIMER2_BASE,TIMER_A);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/TIMER_CAPTURE/" data-id="ckmm8nzw60012sk3d47l3166p" data-title="Timer Capture" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-UART" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/UART/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/UART/">UART</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h1><p>UART能干什么？</p>
<p>能用来通信。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wxc971231/article/details/95624942?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.control">感谢这个人的博客</a></p>
<h3 id="基本功能-向上位机输出一个字符"><a href="#基本功能-向上位机输出一个字符" class="headerlink" title="基本功能 向上位机输出一个字符"></a>基本功能 向上位机输出一个字符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使能UART和GPIO</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);</span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);</span><br><span class="line"><span class="comment">//复用GPIO口为UART功能</span></span><br><span class="line">GPIOPinConfigure(GPIO_PA0_U0RX);</span><br><span class="line">GPIOPinConfigure(GPIO_PA1_U0TX);</span><br><span class="line">GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);</span><br><span class="line"><span class="comment">//设置UART组、频率、波特率、模式</span></span><br><span class="line">UARTConfigSetExpClk(UART0_BASE, SysCtlClockGet(), <span class="number">115200</span>, (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE));</span><br><span class="line"><span class="comment">//输出字符</span></span><br><span class="line">UARTCharPut(UART0_BASE, <span class="string">&#x27;E&#x27;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>模式说明：The ui32Config parameter is the logical OR of three values: the number of data bits, the number of stop bits, and the parity. UART_CONFIG_WLEN_8, UART_CONFIG_WLEN_7, UART_CONFIG_WLEN_6, and UART_CONFIG_WLEN_5 select from eight to five data bits per byte (respectively). UART_CONFIG_STOP_ONE and UART_CONFIG_STOP_TWO select one or two stop bits (respectively). UART_CONFIG_PAR_NONE, UART_CONFIG_PAR_EVEN, UART_CONFIG_PAR_ODD, UART_CONFIG_PAR_ONE, and UART_CONFIG_PAR_ZERO select the parity mode (no parity bit, even parity bit, odd parity bit, parity bit always one, and parity bit always zero,<br>respectively).</p>
<p>就是设置每一个byte有多少数据位，多长停止位，多长奇偶校验位</p>
</blockquote>
<h3 id="进阶功能-格式化输出到上位机"><a href="#进阶功能-格式化输出到上位机" class="headerlink" title="进阶功能 格式化输出到上位机"></a>进阶功能 格式化输出到上位机</h3><ul>
<li>UART时钟、波特率配置函数需要从<code>UARTConfigSetExpClk</code>变为<code>UARTStdioConfig</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使能外设</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_UART1);</span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置复用功能</span></span><br><span class="line">GPIOPinConfigure(GPIO_PB0_U1RX);</span><br><span class="line">GPIOPinConfigure(GPIO_PB1_U1TX);</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配UART信号</span></span><br><span class="line">GPIOPinTypeUART(GPIO_PORTB_BASE,GPIO_PIN_0|GPIO_PIN_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置UART参数(这样配置可以用UARTprintf)</span></span><br><span class="line">UARTClockSourceSet(UART1_BASE, UART_CLOCK_PIOSC);	</span><br><span class="line"><span class="comment">//使用16MHz内部高精度振荡器(PIOSC)作为UART模块时钟</span></span><br><span class="line">UARTStdioConfig(<span class="number">1</span>,<span class="number">115200</span>, <span class="number">16000000</span>);</span><br><span class="line"><span class="comment">//UART编号、波特率、UART时钟频率（频率要和上一行设的一致）</span></span><br><span class="line"></span><br><span class="line">UARTprintf(<span class="string">&quot;Enter Text: \n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> getChar;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	getChar=UARTCharGet(UART1_BASE);</span><br><span class="line">	UARTCharPut(UART1_BASE,getChar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更加进阶的功能-UART中断"><a href="#更加进阶的功能-UART中断" class="headerlink" title="更加进阶的功能 UART中断"></a>更加进阶的功能 UART中断</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureUART</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Enable the GPIO Peripheral used by the UART.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);</span><br><span class="line"></span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Configure GPIO Pins for UART mode.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    GPIOPinConfigure(GPIO_PC4_U1RX);</span><br><span class="line">    GPIOPinConfigure(GPIO_PC5_U1TX);</span><br><span class="line">    GPIOPinTypeUART(GPIO_PORTC_BASE, GPIO_PIN_4 | GPIO_PIN_5);</span><br><span class="line"></span><br><span class="line">    UARTClockSourceSet(UART1_BASE, UART_CLOCK_PIOSC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Initialize the UART for console I/O.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    UARTStdioConfig(<span class="number">1</span>, <span class="number">115200</span>, <span class="number">16000000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UARTIntHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//清除中断标志</span></span><br><span class="line">       <span class="keyword">uint32_t</span> ui32Status;</span><br><span class="line">       ui32Status = UARTIntStatus(UART1_BASE, <span class="literal">true</span>);</span><br><span class="line">       UARTIntClear(UART1_BASE, ui32Status);</span><br><span class="line">       <span class="comment">//循环直到接受队列中不存在字符</span></span><br><span class="line">       <span class="keyword">while</span>(UARTCharsAvail(UART1_BASE))<span class="comment">//loop while there are chars</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//串口输出一个char型</span></span><br><span class="line">           UARTCharPutNonBlocking(UART1_BASE,UARTCharGetNonBlocking(UART1_BASE));</span><br><span class="line">           <span class="comment">//闪一下灯</span></span><br><span class="line">           GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, GPIO_PIN_2);</span><br><span class="line">           SysCtlDelay(SysCtlClockGet() /<span class="number">10</span> / <span class="number">3</span>);</span><br><span class="line">           GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, <span class="number">0</span>);</span><br><span class="line">           SysCtlDelay(SysCtlClockGet() / <span class="number">10</span> / <span class="number">3</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IntMasterEnable();</span><br><span class="line">    IntEnable(INT_UART1);</span><br><span class="line">    UARTIntEnable(UART1_BASE,UART_INT_RX|UART_INT_RT);</span><br><span class="line">    UARTIntRegister(UART1_BASE,UARTIntHandler);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MAP_FPULazyStackingEnable();</span><br><span class="line">    MAP_SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ |</span><br><span class="line">                       SYSCTL_OSC_MAIN);</span><br><span class="line">    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line">    MAP_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_2);</span><br><span class="line">    ConfigureUART();</span><br><span class="line">    int_init();</span><br><span class="line">    UARTprintf(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="至高功能-测试FIFO"><a href="#至高功能-测试FIFO" class="headerlink" title="至高功能 测试FIFO"></a>至高功能 测试FIFO</h3><p>代码放在这，有时间再看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置接收中断，当接收FIFO半满（8byte）时触发。利用串口调试助手一个char一个char发送。</span></span><br><span class="line"><span class="comment">//观察到发送8个char后进入中断，FIFO测试成功</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/tm4c123gh6pm.h&quot;</span>				<span class="comment">//Register Definitions</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_memmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/sysctl.h&quot;</span></span></span><br><span class="line"><span class="comment">//#include &quot;inc/hw_ints.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;uartstdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/pin_map.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> delay_ms(n); SysCtlDelay(n*(SysCtlClockGet()/3000));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UARTIntHandler</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> ui32Status;</span><br><span class="line">	ui32Status = UARTIntStatus(UART1_BASE, <span class="literal">true</span>); <span class="comment">//get interrupt status</span></span><br><span class="line">	UARTIntClear(UART1_BASE, ui32Status); 				<span class="comment">//clear the asserted interrupts</span></span><br><span class="line">	<span class="keyword">while</span>(UARTCharsAvail(UART1_BASE)) 						<span class="comment">//loop while there are chars</span></span><br><span class="line">	&#123;</span><br><span class="line">		UARTCharPutNonBlocking(UART1_BASE, UARTCharGetNonBlocking(UART1_BASE)); <span class="comment">//echo character</span></span><br><span class="line">		GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, GPIO_PIN_2); <span class="comment">//blink LED</span></span><br><span class="line">		delay_ms(<span class="number">1</span>);</span><br><span class="line">		GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, <span class="number">0</span>); <span class="comment">//turn off LED</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN | SYSCTL_XTAL_16MHZ);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使能外设</span></span><br><span class="line">	SysCtlPeripheralEnable(SYSCTL_PERIPH_UART1);</span><br><span class="line">	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置复用功能</span></span><br><span class="line">	GPIOPinConfigure(GPIO_PB0_U1RX);</span><br><span class="line">	GPIOPinConfigure(GPIO_PB1_U1TX);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//分配UART信号</span></span><br><span class="line">	GPIOPinTypeUART(GPIO_PORTB_BASE,GPIO_PIN_0|GPIO_PIN_1);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//LED配置</span></span><br><span class="line">	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF); 				<span class="comment">//enable GPIO port for LED</span></span><br><span class="line">	GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_2); <span class="comment">//enable pin for LED PF2</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//串口参数设置</span></span><br><span class="line">	UARTClockSourceSet(UART1_BASE, UART_CLOCK_PIOSC);	<span class="comment">//使用16MHz内部高精度振荡器(PIOSC)作为UART模块时钟</span></span><br><span class="line">	UARTStdioConfig(<span class="number">1</span>,<span class="number">115200</span>, <span class="number">16000000</span>);							<span class="comment">//UART编号、波特率、UART时钟频率（频率要和上一行设的一致）</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//FIFO配置，</span></span><br><span class="line">	UARTFIFOLevelSet(UART1_BASE,UART_FIFO_TX4_8,UART_FIFO_RX4_8);	<span class="comment">//FIFO填入半满（8byte）时触发中断</span></span><br><span class="line">	UARTFIFOEnable(UART1_BASE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//中断使能</span></span><br><span class="line">	IntMasterEnable(); 																			<span class="comment">//enable processor interrupts</span></span><br><span class="line">	IntEnable(INT_UART1); 																	<span class="comment">//enable the UART interrupt</span></span><br><span class="line">	UARTIntEnable(UART1_BASE, UART_INT_RX); 	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册中断服务函数</span></span><br><span class="line">	UARTIntRegister(UART1_BASE,UARTIntHandler);</span><br><span class="line">	</span><br><span class="line">	UARTprintf(<span class="string">&quot;Enter Text: \n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">//let interrupt handler do the UART echo function</span></span><br><span class="line">	&#123;	</span><br><span class="line">		;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>进一步进行其他FIFO中断测试，如下：</p>
<ul>
<li><strong>打开FIFO的情况下</strong>，打开<code>UART_INT_OE</code>（FIFO溢出中断），此时<strong>FIFO深度无作用</strong>，FIFO接收17个（FIFO溢出）后进入中断，第17个byte丢失，会输出FIFO中存储的所有16个字符，特别注意FIFO溢出是一个错误引发的中断，在中断服务函数中，<strong>除了用<code>UARTIntClear</code>清除标志，还要写一句<code>HWREG(UART1_BASE+UART_O_ECR)=0;</code>清除错误标志</strong>，否则中断只能进一次。</li>
<li><strong>关闭FIFO的情况下（相当于FIFO深度为1）</strong>，打开<code>UART_INT_OE</code>（FIFO溢出中断），连续收到两个byte溢出，在中断中打印第一个byte；打开<code>UART_INT_RX</code>（FIFO溢出中断），每收到一个byte都会进中断打印</li>
</ul>
<h2 id="部分库函数小结"><a href="#部分库函数小结" class="headerlink" title="部分库函数小结"></a>部分库函数小结</h2><h4 id="（1）void-UARTprintf-const-char-pcString-…"><a href="#（1）void-UARTprintf-const-char-pcString-…" class="headerlink" title="（1）void UARTprintf(const char *pcString, …)"></a>（1）void UARTprintf(const char *pcString, …)</h4><ol>
<li>包含<code>uartstdio.c</code>和<code>uartstdio.h</code>后可用</li>
<li>类似C语言printf()</li>
</ol>
<h4 id="（2）void-UARTCharPut-uint32-t-ui32Base-unsigned-char-ucData"><a href="#（2）void-UARTCharPut-uint32-t-ui32Base-unsigned-char-ucData" class="headerlink" title="（2）void UARTCharPut(uint32_t ui32Base, unsigned char ucData)"></a>（2）void UARTCharPut(uint32_t ui32Base, unsigned char ucData)</h4><ol>
<li>串口输出一个char型</li>
<li>等待FIFO中有数据再发送</li>
</ol>
<h4 id="（3）int32-t-UARTCharGet-uint32-t-ui32Base"><a href="#（3）int32-t-UARTCharGet-uint32-t-ui32Base" class="headerlink" title="（3）int32_t UARTCharGet(uint32_t ui32Base)"></a>（3）int32_t UARTCharGet(uint32_t ui32Base)</h4><ol>
<li>串口接收一个uint32_t型数据</li>
<li>等待FIFO中有数据再接收</li>
</ol>
<h4 id="（4）bool-UARTCharPutNonBlocking-uint32-t-ui32Base-unsigned-char-ucData"><a href="#（4）bool-UARTCharPutNonBlocking-uint32-t-ui32Base-unsigned-char-ucData" class="headerlink" title="（4）bool UARTCharPutNonBlocking(uint32_t ui32Base, unsigned char ucData)"></a>（4）bool UARTCharPutNonBlocking(uint32_t ui32Base, unsigned char ucData)</h4><ol>
<li>串口输出一个char型</li>
<li>若发送时FIFO已满时，直接返回false而不在那循环等待</li>
</ol>
<h4 id="（5）int32-t-UARTCharGetNonBlocking-uint32-t-ui32Base"><a href="#（5）int32-t-UARTCharGetNonBlocking-uint32-t-ui32Base" class="headerlink" title="（5）int32_t UARTCharGetNonBlocking(uint32_t ui32Base)"></a>（5）int32_t UARTCharGetNonBlocking(uint32_t ui32Base)</h4><ol>
<li>串口接收一个uint32_t型数据</li>
<li>如果遇到接收时FIFO为空，直接返回false而不在那循环等待</li>
</ol>
<h4 id="（6）void-UARTFIFOLevelSet-uint32-t-ui32Base-uint32-t-ui32TxLevel-uint32-t-ui32RxLevel"><a href="#（6）void-UARTFIFOLevelSet-uint32-t-ui32Base-uint32-t-ui32TxLevel-uint32-t-ui32RxLevel" class="headerlink" title="（6）void UARTFIFOLevelSet(uint32_t ui32Base, uint32_t ui32TxLevel,uint32_t ui32RxLevel)"></a>（6）void UARTFIFOLevelSet(uint32_t ui32Base, uint32_t ui32TxLevel,uint32_t ui32RxLevel)</h4><ol>
<li>配置输入输出FIFO的深度</li>
</ol>
<h4 id="（7）void-UARTFIFOEnable-uint32-t-ui32Base"><a href="#（7）void-UARTFIFOEnable-uint32-t-ui32Base" class="headerlink" title="（7）void UARTFIFOEnable(uint32_t ui32Base)"></a>（7）void UARTFIFOEnable(uint32_t ui32Base)</h4><ol>
<li>开启某UART的FIFO功能</li>
</ol>
<hr>
<h2 id="UART向上位机发送信息模板"><a href="#UART向上位机发送信息模板" class="headerlink" title="UART向上位机发送信息模板"></a>UART向上位机发送信息模板</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ConfigureUART();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureUART</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);</span><br><span class="line">    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);</span><br><span class="line">    ROM_GPIOPinConfigure(GPIO_PA0_U0RX);</span><br><span class="line">    ROM_GPIOPinConfigure(GPIO_PA1_U0TX);</span><br><span class="line">    ROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);</span><br><span class="line">    UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);</span><br><span class="line">    UARTStdioConfig(<span class="number">0</span>, <span class="number">115200</span>, <span class="number">16000000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/UART/" data-id="ckmm8nzw70014sk3da6mt16ri" data-title="UART" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/midi/" rel="tag">midi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stm32/" rel="tag">stm32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/midi/" style="font-size: 10px;">midi</a> <a href="/tags/stm32/" style="font-size: 15px;">stm32</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 20px;">单片机</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/23/002-GPIO/">stm32_GPIO</a>
          </li>
        
          <li>
            <a href="/2021/03/15/001-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/">new project</a>
          </li>
        
          <li>
            <a href="/2021/03/15/%E5%8D%95%E7%89%87%E6%9C%BA%E6%A6%82%E5%86%B5/">单片机概况</a>
          </li>
        
          <li>
            <a href="/2021/03/07/permutation/">generate permutation</a>
          </li>
        
          <li>
            <a href="/2021/03/06/%E4%BC%91%E7%9C%A0%E6%A8%A1%E5%9D%97/">休眠模块</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 smallcracker<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
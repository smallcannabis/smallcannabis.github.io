<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Welcome to smallcracker&#39;s personal website</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Welcome to smallcracker&#39;s personal website">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Welcome to smallcracker&#39;s personal website">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="smallcracker">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Welcome to smallcracker's personal website" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Welcome to smallcracker&#39;s personal website</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">联系方式：1426090870</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-FPU" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/30/FPU/" class="article-date">
  <time class="dt-published" datetime="2021-01-29T16:00:00.000Z" itemprop="datePublished">2021-01-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/30/FPU/">FPU</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="FPU"><a href="#FPU" class="headerlink" title="FPU"></a>FPU</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FPU指的是浮点运算单元。默认情况下，我们不能使用浮点数，只有使能了FPU才能浮点数。如果不打开浮点运算单元就用浮点数的话，单片机就会产生一个NOCP错误。（RTOS可以利用这个特性判断哪一项任务使用了浮点运算单元，以此只在涉及到这些任务的task switch中执行FPU。）</p>
<p>当处理器执行一条中断命令时，有三种办法处理浮点运算内容：1.不去算 2.总是存下来浮点运算内容 3.对浮点运算内容执行一个 lazy save/restore 。</p>
<p>如果不去算的话，中断栈帧就和没有浮点运算单元的Cortex-M 处理器的就一样了。（当那些主程序用到浮点运算，中断函数不用浮点运算时，这种方法会特别好用）(没看出来)（我们像这样不存储浮点运算内容的话，就能减少对栈的使用，降低中断延迟）</p>
<p>除此以外，我们还能把浮点运算内容存储总是到栈里面。这种方法允许在中断函数里面使用浮点运算，代价是栈的使用会增加，中断延迟会增加（因为我们还要向栈里面多写一些东西）。这种方法还有一个优点，那就是在中断函数的栈帧内一直存着浮点运算单元。</p>
<p>对浮点运算内容的默认处理是执行一个lazy save/restore。当我们开始一个中断时，在栈里面我们为浮点运算内容预留出一部分空间（留着一会往里面写内容）。这种方法能降低中断的延迟，因为一会我们就只用去声明整数了。然后如果要执行一个浮点运算的话，我们就把浮点运算内容写到这个浮点运算指令前面。最终，当从中断返回的时候，浮点运算内容就会留在栈里面，直到它被复写。这种方法既保证了中断的快速反应，用能让我们在中断函数 里面使用浮点运算指令。</p>
<p>FPU在异常出现时会产生一个中断（比如说向下、向上溢出、除以零、无效操作，非法输入等情况下）。我们可以利用这些中断搞事情。</p>
<p>FPU也是可以被改造的。我们可以改造半精度浮点数值得格式，对无穷大数的处理，清零模式（这会牺牲完整的IEEE规范来提升速度）以及结果的循环模式。</p>
<p>头文件是driverlib/fpu.h</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/30/FPU/" data-id="ckmsxdddo000rjk3d7ent7q7l" data-title="FPU" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-创建项目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T17:46:40.996Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<p>title：怎样新建一个项目<br>date：2021-1-29</p>
<h2 id="tag：单片机"><a href="#tag：单片机" class="headerlink" title="tag：单片机"></a>tag：单片机</h2><h1 id="怎样新建一个项目"><a href="#怎样新建一个项目" class="headerlink" title="怎样新建一个项目"></a>怎样新建一个项目</h1><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><ul>
<li>file- new ccs project</li>
<li>target里选择c系列</li>
<li>后面选择对应的单片机</li>
<li>connection里面选择stellaris</li>
<li>name里面起一个名字</li>
<li>下面选择with main.c</li>
</ul>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><ul>
<li><p>设置工程</p>
</li>
<li><p>打开projects 的properties</p>
</li>
<li><p>打开build的arm compiler 的include options 添加ti中的Tiva ware c这个文件夹</p>
</li>
<li><p>还有arm linker 的file search path的上面的那个框 其中要添加Tiva ware c这个文件夹中的driverlib的ccs 的debug的driverlib.lib</p>
</li>
</ul>
<p>这样就配置完成了，可以开始写代码了</p>
<hr>
<h2 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_memmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_ints.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_memmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_pwm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/fpu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/pin_map.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/rom.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/rom_map.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/sysctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utils/uartstdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/pwm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureUART</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);</span><br><span class="line">    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);</span><br><span class="line">    ROM_GPIOPinConfigure(GPIO_PA0_U0RX);</span><br><span class="line">    ROM_GPIOPinConfigure(GPIO_PA1_U0TX);</span><br><span class="line">    ROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);</span><br><span class="line">    UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);</span><br><span class="line">    UARTStdioConfig(<span class="number">0</span>, <span class="number">115200</span>, <span class="number">16000000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> clock;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    FPULazyStackingEnable();</span><br><span class="line">    <span class="comment">//使能系统时钟为50MHz</span></span><br><span class="line">    SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN);</span><br><span class="line">    <span class="comment">//延时函数</span></span><br><span class="line">    clock=SysCtlClockGet();</span><br><span class="line">    ROM_SysCtlDelay ( clock *ms / <span class="number">3000</span>);</span><br><span class="line">    ConfigureUART();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/" data-id="ckmsxdde50024jk3dhlv01j6z" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-001-创建项目" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/001-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/001-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/">怎样新建一个项目</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="怎样新建一个项目"><a href="#怎样新建一个项目" class="headerlink" title="怎样新建一个项目"></a>怎样新建一个项目</h1><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><ul>
<li>file- new ccs project</li>
<li>target里选择c系列</li>
<li>后面选择对应的单片机</li>
<li>connection里面选择stellaris</li>
<li>name里面起一个名字</li>
<li>下面选择with main.c</li>
</ul>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><ul>
<li><p>设置工程</p>
</li>
<li><p>打开projects 的properties</p>
</li>
<li><p>打开build的arm compiler 的include options 添加ti中的Tiva ware c这个文件夹</p>
</li>
<li><p>还有arm linker 的file search path的上面的那个框 其中要添加Tiva ware c这个文件夹中的driverlib的ccs 的debug的driverlib.lib</p>
</li>
</ul>
<p>这样就配置完成了，可以开始写代码了</p>
<hr>
<h2 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_memmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_ints.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_memmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_pwm.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/debug.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/timer.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/fpu.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/pin_map.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/rom.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/rom_map.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/sysctl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;utils/uartstdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/pwm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> delay(ms) ROM_SysCtlDelay(clock*ms/3000)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> clock;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureUART</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prt_f</span><span class="params">(<span class="keyword">float</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(w&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        UARTprintf(<span class="string">&quot;%d.&quot;</span>,(<span class="keyword">int</span>)w);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        UARTprintf(<span class="string">&quot;0.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tem=(<span class="keyword">int</span>)(w*<span class="number">10000000</span>)%<span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">if</span>(tem&lt;<span class="number">1000000</span>)UARTprintf(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(tem&lt;<span class="number">100000</span>)UARTprintf(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(tem&lt;<span class="number">10000</span>)UARTprintf(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(tem&lt;<span class="number">1000</span>)UARTprintf(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(tem&lt;<span class="number">100</span>)UARTprintf(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(tem&lt;<span class="number">10</span>)UARTprintf(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(tem&lt;<span class="number">1</span>)UARTprintf(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    UARTprintf(<span class="string">&quot;%d&quot;</span>,tem);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> detection_queue[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> detection_index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> state=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> duration[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> message_index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tick=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> threshold=<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WTimer1AIntHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ulstatus = TimerIntStatus(WTIMER1_BASE,TIMER_TIMA_TIMEOUT);</span><br><span class="line">    TimerIntClear(WTIMER1_BASE, ulstatus);</span><br><span class="line">    <span class="keyword">int</span> ReadPin1 = GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4);<span class="comment">//检测</span></span><br><span class="line">    <span class="keyword">int</span> flag=((ReadPin1&amp;GPIO_PIN_4) != GPIO_PIN_4);</span><br><span class="line">    detection_queue[detection_index]=flag;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=threshold;i++)sum+=(<span class="keyword">int</span>)detection_queue[detection_index-i];</span><br><span class="line">    <span class="keyword">if</span>(tick&gt;threshold)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum==threshold&amp;&amp;state==<span class="literal">false</span>)&#123;</span><br><span class="line">            state=<span class="literal">true</span>;</span><br><span class="line">            duration[message_index]=tick;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">0</span>&amp;&amp;state==<span class="literal">true</span>)&#123;</span><br><span class="line">            state=<span class="literal">false</span>;</span><br><span class="line">            duration[message_index]=tick-duration[message_index];</span><br><span class="line">            UARTprintf(<span class="string">&quot;bottom up. message index is %d\nduration:%d\n&quot;</span>,message_index,duration[message_index]);</span><br><span class="line">            message_index++;</span><br><span class="line">            message_index%=<span class="number">110</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tick++;</span><br><span class="line">    detection_index++;</span><br><span class="line">    detection_index%=<span class="number">110</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Configurebottom</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line">    GPIODirModeSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_DIR_MODE_IN);</span><br><span class="line">    GPIOPadConfigSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);</span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_WTIMER1);</span><br><span class="line">    TimerConfigure(WTIMER1_BASE,TIMER_CFG_PERIODIC);</span><br><span class="line">    TimerLoadSet64(WTIMER1_BASE, clock/<span class="number">500</span>);</span><br><span class="line">    TimerIntRegister(WTIMER1_BASE, TIMER_A, WTimer1AIntHandler);</span><br><span class="line">    IntMasterEnable();</span><br><span class="line">    TimerIntEnable(WTIMER1_BASE, TIMER_TIMA_TIMEOUT);</span><br><span class="line">    IntEnable(INT_WTIMER1A);</span><br><span class="line">    TimerEnable(WTIMER1_BASE, TIMER_A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureEverything</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FPUEnable();</span><br><span class="line">    FPULazyStackingEnable();</span><br><span class="line">    SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN);</span><br><span class="line">    clock=SysCtlClockGet();</span><br><span class="line">    ConfigureUART();</span><br><span class="line">    Configurebottom();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConfigureEverything();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureUART</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);</span><br><span class="line">    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);</span><br><span class="line">    ROM_GPIOPinConfigure(GPIO_PA0_U0RX);</span><br><span class="line">    ROM_GPIOPinConfigure(GPIO_PA1_U0TX);</span><br><span class="line">    ROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);</span><br><span class="line">    UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);</span><br><span class="line">    UARTStdioConfig(<span class="number">0</span>, <span class="number">115200</span>, <span class="number">16000000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/001-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE/" data-id="ckmsxdddb0001jk3d43713jti" data-title="怎样新建一个项目" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-ADC interrupt" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/ADC%20interrupt/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/ADC%20interrupt/">ADC中断</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="ADC中断"><a href="#ADC中断" class="headerlink" title="ADC中断"></a>ADC中断</h1><h3 id="一、相关函数介绍"><a href="#一、相关函数介绍" class="headerlink" title="一、相关函数介绍"></a>一、相关函数介绍</h3><ol>
<li><code>ADCIntRegister()</code> 和<code>ADCIntUnregister()</code>用于为ADC中断注册（注销）一个中断函数</li>
<li><code>ADCIntEnable()</code> 和 <code>ADCIntDisable</code> 使能（失能）一个采样序列中断</li>
<li><code>ADCIntClear()</code> 清除采样序列中断源</li>
<li><code>ADCIntStatus()</code> 获取当前中断状态</li>
</ol>
<h3 id="二、怎样触发中断"><a href="#二、怎样触发中断" class="headerlink" title="二、怎样触发中断"></a>二、怎样触发中断</h3><p>在配置采样通道的时候，如果参数设置有 <code>ADC_CTL_IE</code> 那么当这个通道采集完之后就会产生一个中断。</p>
<h3 id="三、例子"><a href="#三、例子" class="headerlink" title="三、例子"></a>三、例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">configureADC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择E3引脚（即CH0）作为ADC输入</span></span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);</span><br><span class="line">    GPIOPinTypeADC(GPIO_PORTE_BASE, GPIO_PIN_3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置采样序列发生器等</span></span><br><span class="line">    ADCSequenceConfigure(ADC0_BASE, <span class="number">0</span>, ADC_TRIGGER_PROCESSOR, <span class="number">0</span>);</span><br><span class="line">    ADCSequenceStepConfigure(ADC0_BASE, <span class="number">0</span>, <span class="number">0</span>,ADC_CTL_IE | ADC_CTL_END | ADC_CTL_CH0);</span><br><span class="line">	</span><br><span class="line">    ADCSequenceEnable(ADC0_BASE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置ADC中断</span></span><br><span class="line">    ADCIntRegister(ADC0_BASE, <span class="number">0</span> , convet);</span><br><span class="line">    ADCIntEnable(ADC0_BASE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、注意"><a href="#四、注意" class="headerlink" title="四、注意"></a>四、注意</h3><p>在写中断函数的时候记得清除中断标记，因为清除中断需要几个时钟周期，所以，我们需要在中断函数一开始就清除中断。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/ADC%20interrupt/" data-id="ckmsxdddj000djk3d76omczvs" data-title="ADC中断" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Analog to Digital Converter" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/Analog%20to%20Digital%20Converter/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/Analog%20to%20Digital%20Converter/">ADC简介</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Analog-to-Digital-Converter（模-数转换器）"><a href="#Analog-to-Digital-Converter（模-数转换器）" class="headerlink" title="Analog to Digital Converter（模-数转换器）"></a>Analog to Digital Converter（模-数转换器）</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>这款单片机有两个完全相同的转换器模块，它们共用12个输入通道。该ADC模块的转换分辨率为12位。</p>
<p>每个ADC模块都包含4个可编程的序列发生器。采样序列发生器（Sample Sequencer 简写为SS）用于采样控制和数据采集。所有序列发生器的实现方法都是相同的，区别仅在于能够捕捉的采样数和FIFO的深度有所不同，捕捉到的每个采样都要存入FIFO中。这四个采样序列发生器，它们可以同时捕获样本。每个序列都可以配置触发事件。第一个序列发生器至多捕获八个样本，第二个和第三个至多捕获四个样本，第四个序列只能捕获一个样本。每一个样本可以在同一路，不同路，或者其他什么顺序。</p>
<p><img src="ADC.png" alt="简介"></p>
<p>如果很多个事件同时被触发的话，可以给样本序列发生器配置优先级确定谁先被捕获。被触发的最高优先级的序列先采样，一定要注意那些频繁触发的事件，如果它们的优先级太高的话，有些低优先级的序列就采不到样了。</p>
<p>ADV数据的硬件过采样可以用来提高精度。过采样的倍率可以2x 4x 8x 16x 32x 或者是32x，但是这样就会相应倍率地降低一个ADC的吞吐量（<a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_4511506f0102xmxw.html">具体可以看这里</a>）。注意所有采样序列只能设置一个统一的硬件过采样倍率。</p>
<p>还可以用软件实现过采样的！单片机支持2x 4x 8x 但是它会相应倍率的降低样本序列的深度的。比如说啊，第一份采样序列地深度是8，在4x过采样模式下，它就只能采两个样本了。这是因为头四个样本被拿去过采样了。每一个采样序列都能设置自己地软件过采样倍率。</p>
<p>一种更加复杂的软件过采样可以用于清除样本深度地减少。如果我们加快ADC触发速率4倍，然后再配置一个4倍地软件过采样，这样就不会减少采样序列容量了，这样做的后果是ADC触发数量就要增加了，因为这种方法需要在ADC驱动本身以外去做调整，所以不被驱动直接支持，如果我们要用这种方法，就不能用驱动里面的函数了。</p>
<p>函数地头文件是driverlib/adc.c 和driverlib/adc.h</p>
<h2 id="二、然后再来看都干了啥"><a href="#二、然后再来看都干了啥" class="headerlink" title="二、然后再来看都干了啥"></a>二、然后再来看都干了啥</h2><h3 id="1-首先使能ADC外设"><a href="#1-首先使能ADC外设" class="headerlink" title="1.首先使能ADC外设"></a>1.首先使能ADC外设</h3><p><code>SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);</code></p>
<h3 id="2-然后开始配置ADC采样序列发生器，主要是配置触发条件和触发优先级"><a href="#2-然后开始配置ADC采样序列发生器，主要是配置触发条件和触发优先级" class="headerlink" title="2.然后开始配置ADC采样序列发生器，主要是配置触发条件和触发优先级"></a>2.然后开始配置ADC采样序列发生器，主要是配置触发条件和触发优先级</h3><p><code>ADCSequenceConfigure();</code><br>这个函数用来配置触发源和采样序列的优先级  </p>
<blockquote>
<p>前两个参数选择是哪个采样序列发生器<br>第三个是触发条件<br>第四个是触发优先级  </p>
</blockquote>
<p>触发条件有这些：</p>
<ul>
<li>处理器触发</li>
<li>AC模块触发</li>
<li>GPIO触发</li>
<li>计时器触发</li>
<li>PWM触发？？以后可以研究一下</li>
<li>一直触发<h3 id="3-配置引脚用于ADC输入"><a href="#3-配置引脚用于ADC输入" class="headerlink" title="3.配置引脚用于ADC输入"></a>3.配置引脚用于ADC输入</h3><code>GPIOPINTypeADC()</code> 配置引脚用于ADC输入 ，注意不是每一个引脚能都拿来作为ADC输入的，<h3 id="4-选取通道并进行余下配置"><a href="#4-选取通道并进行余下配置" class="headerlink" title="4.选取通道并进行余下配置"></a>4.选取通道并进行余下配置</h3><code>ADCSequenceStepConfigure();</code><br>配置采样序列发生器的一个step  <blockquote>
<p>前两个参数选择哪一个采样序列发生器<br>第三个参数是要设置的那个step<br>第四个参数是这个step的设置  </p>
</blockquote>
</li>
</ul>
<p>参数设置分析：这个参数应该是一系列参数的OR，主要设置了一个step的模式（单端输入还是差分输入），选用哪个输入通道，输入完要不要触发中断，以及选择的数字比较器（？？）</p>
<h3 id="5-获取采样结果"><a href="#5-获取采样结果" class="headerlink" title="5.获取采样结果"></a>5.获取采样结果</h3><p><code>ADCSequenceDataGet();</code></p>
<blockquote>
<p>第一个是ADC的基址<br>第二个是ADC的采样序列数<br>第三个填一个32位地址，表示把数填在这里</p>
</blockquote>
<p>其实这个函数还有返回值，返回值就是get到的数</p>
<h3 id="6-使能ADC采样序列发生器"><a href="#6-使能ADC采样序列发生器" class="headerlink" title="6.使能ADC采样序列发生器"></a>6.使能ADC采样序列发生器</h3><p><code>ADCSequenceEnable()</code></p>
<blockquote>
<p>一共两个参数，表示选择的那个采样序列发生器</p>
</blockquote>
<h2 id="三、直接上例程！"><a href="#三、直接上例程！" class="headerlink" title="三、直接上例程！"></a>三、直接上例程！</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义变量用于存储采得样本</span></span><br><span class="line"><span class="keyword">uint32_t</span> ui32Value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使能ADC0模块并等待其准备完成</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0);</span><br><span class="line"><span class="keyword">while</span>(!SysCtlPeripheralReady(SYSCTL_PERIPH_ADC0))&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置E3引脚（对应CH0）为这个采样序列发生器的通道</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);</span><br><span class="line">GPIOPinTypeADC(GPIO_PORTE_BASE, GPIO_PIN_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使能第一个采样序列发生器来捕捉CH0的值</span></span><br><span class="line">ADCSequenceConfigure(ADC0_BASE, <span class="number">0</span>, ADC_TRIGGER_PROCESSOR, <span class="number">0</span>);</span><br><span class="line">ADCSequenceStepConfigure(ADC0_BASE, <span class="number">0</span>, <span class="number">0</span>,ADC_CTL_IE | ADC_CTL_END | ADC_CTL_CH0);</span><br><span class="line">ADCSequenceEnable(ADC0_BASE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以后每次触发时都要加上这几句</span></span><br><span class="line">ADCProcessorTrigger(ADC0_BASE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span>(!ADCIntStatus(ADC0_BASE, <span class="number">0</span>, <span class="literal">false</span>))&#123;&#125;</span><br><span class="line">ADCSequenceDataGet(ADC0_BASE, <span class="number">0</span>, &amp;ui32Value);</span><br></pre></td></tr></table></figure>
<p><img src="ADC引脚.jpg" alt="pin"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/Analog%20to%20Digital%20Converter/" data-id="ckmsxdddm000jjk3d76r75foy" data-title="ADC简介" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-GPIO_PWM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/GPIO_PWM/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/GPIO_PWM/">GPIO PWM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="GPIOPinTypePWM"><a href="#GPIOPinTypePWM" class="headerlink" title="GPIOPinTypePWM"></a>GPIOPinTypePWM</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wxc971231/article/details/95355645">感谢这位老哥</a></p>
<p>Configures pin(s) for use by the PWM peripheral.</p>
<blockquote>
<p>配置引脚以用作PWM外设</p>
</blockquote>
<p>Prototype:<br>void<br>GPIOPinTypePWM(uint32_t ui32Port,<br>uint8_t ui8Pins)</p>
<p>Parameters:<br>ui32Port is the base address of the GPIO port.<br>ui8Pins is the bit-packed representation of the pin(s).<br>Description:<br>The PWM pins must be properly configured for the PWM peripheral to function correctly. This function provides a typical configuration for those pin(s); other configurations may work as well depending upon the board setup (for example, using the on-chip pull-ups). </p>
<blockquote>
<p>为了使PWM外设正常工作，一定要正确配置PWM引脚，这个函数为这些引脚提供了典型的配置，其他的配置也可能正确配置。</p>
</blockquote>
<p>The pin(s) are specified using a bit-packed byte, where each bit that is set identifies the pin to be accessed, and where bit 0 of the byte represents GPIO port pin 0, bit 1 represents GPIO port pin 1, and so on.</p>
<p>Note:<br>This function cannot be used to turn any pin into a PWM pin; it only configures a PWM pin<br>for proper operation. Note that a GPIOPinConfigure() function call is also required to properly<br>configure a pin for the PWM function.</p>
<blockquote>
<p>要配置一个引脚发挥PWM功能，还需调用GPIOPinConfigure()函数</p>
</blockquote>
<p>A subset of GPIO pins on Tiva devices, notably those used by the JTAG/SWD interface and<br>any pin capable of acting as an NMI input, are locked against inadvertent reconfiguration.<br>These pins must be unlocked using direct register writes to the relevant GPIO_O_LOCK and<br>GPIO_O_CR registers before this function can be called. Please see the “gpio_jtag” example<br>application for the mechanism required and consult your part datasheet for information on<br>affected pins.</p>
<p>Returns:<br>None.</p>
<h2 id="二、例程"><a href="#二、例程" class="headerlink" title="二、例程"></a>二、例程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置PWM预分频，这里不分频</span></span><br><span class="line">SysCtlPWMClockSet(SYSCTL_PWMDIV_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使能两个模块的时钟</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//复用引脚</span></span><br><span class="line">GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_2);</span><br><span class="line">GPIOPinTypePWM(GPIO_PORTF_BASE, GPIO_PIN_3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置信号分配</span></span><br><span class="line">GPIOPinConfigure(GPIO_PF2_M1PWM6);</span><br><span class="line">GPIOPinConfigure(GPIO_PF3_M1PWM7);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置PWM发生器</span></span><br><span class="line">PWMGenConfigure(PWM1_BASE, PWM_GEN_3, PWM_GEN_MODE_DOWN | PWM_GEN_MODE_NO_SYNC);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置周期 表示100hz</span></span><br><span class="line">PWMGenPeriodSet(PWM1_BASE, PWM_GEN_3, <span class="number">50000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置占空比</span></span><br><span class="line">PWMPulseWidthSet(PWM1_BASE, PWM_OUT_6, <span class="number">0</span>);</span><br><span class="line">PWMPulseWidthSet(PWM1_BASE, PWM_OUT_7, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使能PWM模块1输出</span></span><br><span class="line">PWMOutputState(PWM1_BASE, (PWM_OUT_6_BIT | PWM_OUT_7_BIT), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使能PWM发生器</span></span><br><span class="line">PWMGenEnable(PWM1_BASE, PWM_GEN_3);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/GPIO_PWM/" data-id="ckmsxdddp000tjk3dgqvo18k4" data-title="GPIO PWM" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-GPIO_interrupt" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/GPIO_interrupt/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/GPIO_interrupt/">GPIO中断</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="GPIO中断"><a href="#GPIO中断" class="headerlink" title="GPIO中断"></a>GPIO中断</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wxc971231/article/details/95173394">资料来源</a></p>
<h2 id="一、函数介绍"><a href="#一、函数介绍" class="headerlink" title="一、函数介绍"></a>一、函数介绍</h2><h4 id="（1）void-GPIOIntTypeSet-uint32-t-ui32Port-uint8-t-ui8Pins-uint32-t-ui32IntType"><a href="#（1）void-GPIOIntTypeSet-uint32-t-ui32Port-uint8-t-ui8Pins-uint32-t-ui32IntType" class="headerlink" title="（1）void GPIOIntTypeSet(uint32_t ui32Port, uint8_t ui8Pins,uint32_t ui32IntType)"></a>（1）void GPIOIntTypeSet(uint32_t ui32Port, uint8_t ui8Pins,uint32_t ui32IntType)</h4><ol>
<li>功能：设置指定引脚的中断触发类型.</li>
<li>参数:<br>（1）ui32Port： GPIO口的基地址<br>（2）ui8Pins： 多个bit-packed格式表示的引脚<br>（3）ui32IntType： 中断触发类型(有以下类型)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_FALLING_EDGE       0x00000000  <span class="comment">// Interrupt on falling edge</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_RISING_EDGE        0x00000004  <span class="comment">// Interrupt on rising edge</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_BOTH_EDGES         0x00000001  <span class="comment">// Interrupt on both edges</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_LOW_LEVEL          0x00000002  <span class="comment">// Interrupt on low level</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_HIGH_LEVEL         0x00000006  <span class="comment">// Interrupt on high level</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO_DISCRETE_INT       0x00010000  <span class="comment">// Interrupt for individual pin</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>中断触发方式是啥？</p>
<p>就是怎样触发这个中断</p>
<p>主要有两种方式</p>
<p>沿触发和电平触发</p>
<p>沿触发比如说时钟中断，在被响应并被清除时，就不会触发，</p>
<p>电平触发比如串口中断，在被响应并清除后，从中断态返回SVC态仍可能会触发中断。</p>
<p>可能顾名思义就可以吧。。</p>
</blockquote>
<h4 id="（2）void-GPIOIntRegister-uint32-t-ui32Port-void-pfnIntHandler-void"><a href="#（2）void-GPIOIntRegister-uint32-t-ui32Port-void-pfnIntHandler-void" class="headerlink" title="（2）void GPIOIntRegister(uint32_t ui32Port, void (*pfnIntHandler)(void))"></a>（2）void GPIOIntRegister(uint32_t ui32Port, void (*pfnIntHandler)(void))</h4><ol>
<li>功能：注册GPIO中断的中断处理程序</li>
<li>参数:<br>（1）ui32Port ：GPIO口的基地址<br>（2）pfnIntHandler： 是GPIO中断服务程序入口地址指针。</li>
<li>说明：<br>（1）不管是什么外设触发的中断，都要<strong>先注册中断服务函数</strong>，告诉程序中断发生时去哪里，类似的函数有<code>SysCtlIntRegister</code>、<code>ADCIntRegister</code>等<br>（2）如果不利用这些中断注册函数，也可以在启动文件中修改中断向量表进行手动注册<br>（3）GPIOIntRegister只能<strong>以GPIO组为单位注册，不能精确到判断哪个引脚发生中断</strong>，因此要在中断服务函数中判断触发中断的引脚，以下为一个示例</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GPIOF中断服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_interrupt</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="comment">//获取中断状态</span></span><br><span class="line">	<span class="keyword">uint32_t</span> s = GPIOIntStatus(GPIO_PORTF_BASE, <span class="literal">true</span>);</span><br><span class="line">	<span class="comment">//如果PF4触发中断</span></span><br><span class="line">			<span class="keyword">if</span>((s&amp;GPIO_PIN_4) == GPIO_PIN_4)</span><br><span class="line">	&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（3）void-GPIOIntEnable-uint32-t-ui32Port-uint32-t-ui32IntFlags"><a href="#（3）void-GPIOIntEnable-uint32-t-ui32Port-uint32-t-ui32IntFlags" class="headerlink" title="（3）void GPIOIntEnable(uint32_t ui32Port, uint32_t ui32IntFlags)"></a>（3）void GPIOIntEnable(uint32_t ui32Port, uint32_t ui32IntFlags)</h4><ol>
<li>功能：使能<strong>指定引脚</strong>的中断.</li>
<li>参数:<br>（1）ui32Port ：GPIO口的基地址<br>（2）ui32IntFlags： 被禁止的中断源中断屏蔽位(指示哪些引脚中断被开启，是以下参数的逻辑或)</li>
</ol>
<h4 id="（4）void-IntEnable-uint32-t-ui32Interrupt"><a href="#（4）void-IntEnable-uint32-t-ui32Interrupt" class="headerlink" title="（4）void IntEnable(uint32_t ui32Interrupt)"></a>（4）void IntEnable(uint32_t ui32Interrupt)</h4><ol>
<li>功能：使能一个中断</li>
<li>参数:<br>（1）ui32Interrupt 指定的被允许的中断.</li>
<li>说明：这个函数是<strong>中断控制器级</strong>的中断使能控制</li>
</ol>
<h4 id="（5）bool-IntMasterEnable-void"><a href="#（5）bool-IntMasterEnable-void" class="headerlink" title="（5）bool IntMasterEnable(void)"></a>（5）bool IntMasterEnable(void)</h4><ol>
<li>功能：使能处理器中断.</li>
<li>参数：无</li>
<li>说明：<br>（1）这是<strong>处理器级</strong>的中断使能控制，它决定处理器要不要处理中断控制器的请求<br>（2）以上三个函数，从低级到高级对应了中断处理通路的三道“开关”，如下图所示</li>
<li><img src="https://img-blog.csdnimg.cn/20190709124218959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3d4Yzk3MTIzMQ==,size_16,color_FFFFFF,t_70" alt="20190709124218959.png (767×468) (csdnimg.cn)"></li>
</ol>
<h5 id="看来要同时有三个级别的中断使能控制。"><a href="#看来要同时有三个级别的中断使能控制。" class="headerlink" title="看来要同时有三个级别的中断使能控制。"></a>看来要同时有三个级别的中断使能控制。</h5><h4 id="（6）uint32-t-GPIOIntStatus-uint32-t-ui32Port-bool-bMasked"><a href="#（6）uint32-t-GPIOIntStatus-uint32-t-ui32Port-bool-bMasked" class="headerlink" title="（6）uint32_t GPIOIntStatus(uint32_t ui32Port, bool bMasked)"></a>（6）uint32_t GPIOIntStatus(uint32_t ui32Port, bool bMasked)</h4><ol>
<li>功能：读取指定GPIO口的中断状态</li>
<li>参数：<br>（1）ui32Port： GPIO口的基地址.<br>（2）bMasked： 指定返回屏蔽的中断状态还是原始的中断状态</li>
<li>说明： 如果bMasked被设置为真，则函数返回被屏蔽的中断状态，否则返回原始的中断状态。解释一下所谓“<strong>被屏蔽的中断状态</strong>”。在<code>GPIOIntEnable</code>这个函数中，没有写在第二个参数<code>ui32IntFlags</code>中的引脚是被屏蔽的（即<strong>不处理它们的中断事件</strong>）。当bMasked为真时，返回GPIOMIS寄存器值，所有被屏蔽的位都是0，否则返回GPIORIS寄存器值，被屏蔽的位也可能是1（因为虽然不处理这些引脚的中断事件，但它们的输入也可能符合中断特征）</li>
<li>就是输出都那个口在中断状态。</li>
</ol>
<h4 id="（7）void-GPIOIntClear-uint32-t-ui32Port-uint32-t-ui32IntFlags"><a href="#（7）void-GPIOIntClear-uint32-t-ui32Port-uint32-t-ui32IntFlags" class="headerlink" title="（7）void GPIOIntClear(uint32_t ui32Port, uint32_t ui32IntFlags)"></a>（7）void GPIOIntClear(uint32_t ui32Port, uint32_t ui32IntFlags)</h4><ol>
<li><p>功能：清除指定中断源标志</p>
</li>
<li><p>参数:<br>（1）ui32Port ：GPIO口的基地址<br>（2）ui32IntFlags ：被清除的中断源中断屏蔽位</p>
</li>
<li><p>发生中断后，对应的中断标志位置1，进入中断服务函数，在服务函数中务必清除中断标志，否则程序将不停地进入中断服务函数</p>
</li>
</ol>
<h2 id="二、例程"><a href="#二、例程" class="headerlink" title="二、例程"></a>二、例程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_INT_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//使能GPIO组，这里设置的是F口</span></span><br><span class="line">   SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line">   <span class="comment">//设置某引脚为输入，这里设置的是PF4</span></span><br><span class="line">   GPIODirModeSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_DIR_MODE_IN);</span><br><span class="line">   <span class="comment">//设置为推挽输入</span></span><br><span class="line">   GPIOPadConfigSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);</span><br><span class="line">   <span class="comment">//配置中断类型为沿下降</span></span><br><span class="line">   GPIOIntTypeSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_FALLING_EDGE);</span><br><span class="line">   <span class="comment">//注册中断函数</span></span><br><span class="line">   GPIOIntRegister(GPIO_PORTF_BASE, io_interrupt);</span><br><span class="line">   <span class="comment">//开启中断</span></span><br><span class="line">   GPIOIntEnable(GPIO_PORTF_BASE, GPIO_PIN_4);</span><br><span class="line">   IntEnable(INT_GPIOF);</span><br><span class="line">   IntMasterEnable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是中断函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">io_interrupt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//中断函数一开始要清除发生的中断标志</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s=GPIOIntStatus(GPIO_PORTF_BASE,<span class="literal">true</span>);</span><br><span class="line">    GPIOIntClear(GPIO_PORTF_BASE, s);</span><br><span class="line">    <span class="comment">//然后判断读取到的是不是设置的引脚</span></span><br><span class="line">    <span class="keyword">if</span>((s&amp;GPIO_PIN_4)==GPIO_PIN_4)<span class="comment">//如果读取到的是PF4</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4));<span class="comment">//等待按键松开</span></span><br><span class="line">        do_something();<span class="comment">//做想做的事情</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/GPIO_interrupt/" data-id="ckmsxdddq000vjk3ddw0qfjkj" data-title="GPIO中断" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-GPIO输出和输入" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/GPIO%E8%BE%93%E5%87%BA%E5%92%8C%E8%BE%93%E5%85%A5/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/GPIO%E8%BE%93%E5%87%BA%E5%92%8C%E8%BE%93%E5%85%A5/">GPIO输入和输出</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="GPIO-输入和输出"><a href="#GPIO-输入和输出" class="headerlink" title="GPIO 输入和输出"></a>GPIO 输入和输出</h1><p>首先使能GPIO接口<br><code>SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</code></p>
<p>接下来设置GPIO模式为输出<br><code>GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_3);</code>  </p>
<ul>
<li><em>如果要设置多个pin的话</em><br><code>GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_2 | GPIO_PIN_4 | GPIO_PIN_5);</code>  </li>
</ul>
<p>最后进行输出<br><code>GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0); 或者 void GPIOPinWrite(Port,Pins,which_pin);</code></p>
<p>GPIO函数一共有三种</p>
<ol>
<li>配置GPIO pins的函数</li>
<li>处理中断的函数</li>
<li>获取pins value的函数</li>
</ol>
<p>配置３２和TI的方式就是不一样的，３２的GPIO是用结构体进行配置，TI则使用函数来进行配置。</p>
<p>TI的普通配置只需要进行GPIO外设使能和方向控制即可。也不是说前面说到的功能模式就不能配置了，如果有需要可以进行其他类型的配置。<br>如果要进行端口高低电平的输出控制，３２和TI也是一样的调用函数来进行配置，分别是：<code>GPIO_SetBits(GPIOE,GPIO_Pin_5);</code>　和　<code>GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, 0);</code></p>
<p>注意：TI的输出高低电平使用的是同一个函数GPIOPinWrite（），对于３２则使用的是两个函数：GPIO_SetBits（）和GPIO_ResetBit（）即可输出高低电平。TI呢，则不是这样的，就连入口参数也不是和３２一样那么简单，GPIOPinWrite（）入口参数就有三个，分别是GPIO_PORTｘ_BASE，GPIO＿PIN＿ｘ，和０（低电平时候为０，但是高电平时候不是１，而是GPIO＿PIN＿ｘ）。例如PF１输出高电平　：<br>GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1, GPIO_PIN_1);</p>
<p>输入输出的模式一般不用管，但应了解浮空输入 上拉输入 下拉输入 模拟输入 开漏输出 推挽输出 复用推挽输出 复用开漏输出</p>
<p>怎样读入呢？</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReadPin1 = GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4);<span class="comment">//检测</span></span><br><span class="line"><span class="keyword">if</span>((ReadPin1&amp;GPIO_PIN_4) != GPIO_PIN_4) &#123; <span class="comment">//如果按下</span></span><br><span class="line">    SysCtlDelay(<span class="number">20</span>*(SysCtlClockGet()/<span class="number">3000</span>));<span class="comment">//消抖</span></span><br><span class="line">    ReadPin1 = GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4);<span class="comment">//再次检测</span></span><br><span class="line">    <span class="keyword">if</span>((ReadPin1&amp;GPIO_PIN_4) != GPIO_PIN_4) &#123;<span class="comment">//再次判断</span></span><br><span class="line">        KeyPress1 = <span class="literal">true</span>;<span class="comment">//如果按下，则置一个标志位</span></span><br><span class="line">        <span class="keyword">while</span>(!GPIOPinRead(GPIO_PORTF_BASE, GPIO_PIN_4))&#123;&#125;<span class="comment">//等按键松开</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="GPIO输出最终模板"><a href="#GPIO输出最终模板" class="headerlink" title="GPIO输出最终模板"></a>GPIO输出最终模板</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使能GPIO外设</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line"><span class="comment">//设置引脚为GPIO输出模式</span></span><br><span class="line">GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_3);</span><br><span class="line"><span class="comment">//引脚输出</span></span><br><span class="line">GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_3, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="部分函数研究"><a href="#部分函数研究" class="headerlink" title="部分函数研究"></a>部分函数研究</h2><ol>
<li><code>GPIODirModeSet()</code><br>描述：设置了管脚的方向是向内、向外还是硬件控制</li>
<li><code>GPIOPadConfigSet()</code><br> 描述：设置了一些引脚的输出驱动强度，和引脚类型<br> GPIO_PIN_TYPE_STD 推挽输出 可以输出高低电平<br> GPIO_PIN_TYPE_STD_WPU 推挽——弱上拉<br> GPIO_PIN_TYPE_STD_WPD 推挽——弱下拉<br> GPIO_PIN_TYPE_OD 开漏输出 IO 输出 0 接 GND， IO 输出 1，悬空，需要外接上拉电阻，才能实现输出<br> GPIO_PIN_TYPE_ANALOG 模拟输出<br> GPIO_PIN_TYPE_WAKE_HIGH 于hibernation mode 有关<br> GPIO_PIN_TYPE_WAKE_LOW  </li>
<li><code>GPIOPinConfigure()</code></li>
<li><code>GPIOPinRead()</code></li>
<li><code>GPIOPinWrite()</code></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/GPIO%E8%BE%93%E5%87%BA%E5%92%8C%E8%BE%93%E5%85%A5/" data-id="ckmsxdddq000xjk3d84ua8ge4" data-title="GPIO输入和输出" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Interrupt Controller(NVIC)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/Interrupt%20Controller(NVIC)/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/Interrupt%20Controller(NVIC)/">中断控制器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Interrupt-Controller-NVIC"><a href="#Interrupt-Controller-NVIC" class="headerlink" title="Interrupt Controller(NVIC)"></a>Interrupt Controller(NVIC)</h1><p>The interrupt controller API provides a set of functions for dealing with the Nested Vectored Interrupt<br>Controller (NVIC). Functions are provided to enable and disable interrupts, register interrupt<br>handlers, and set the priority of interrupts.</p>
<blockquote>
<p>中断控制器API提供了一系列与内置向量式中断控制器有关的函数，这些函数能使能/使不能中断，注册中断，设置中断优先级等</p>
</blockquote>
<p>The NVIC provides global interrupt masking, prioritization, and handler dispatching. Devices within<br>the Tiva family support up to 154 interrupt sources and eight priority levels. Individual interrupt<br>sources can be masked, and the processor interrupt can be globally masked as well (without affecting<br>the individual source masks).</p>
<blockquote>
<p>NVIC提供了全局中断屏蔽，优先级和处理器调度功能，在Tiva系列设备里至多支持154个中断和8个中断级，单个中断源可以被屏蔽，处理器屏蔽也可以被全局屏蔽（不影响单个中断源的屏蔽哦）</p>
</blockquote>
<p>The NVIC is tightly coupled with the Cortex-M microprocessor. When the processor responds to<br>an interrupt, the NVIC supplies the address of the function to handle the interrupt directly to the<br>processor. This action eliminates the need for a global interrupt handler that queries the interrupt<br>controller to determine the cause of the interrupt and branch to the appropriate handler, reducing<br>interrupt response time.</p>
<blockquote>
<p>NVIC紧密搭配着cortex_M微处理器。当处理器对中断作出反应时，NVIC直接把处理中断的函数的地址提供给处理器，此操作无需使用全局中断处理程序来查询中断控制器以确定中断的原因，并分支到相应的处理程序，从而减少中断响应时间。  </p>
</blockquote>
<p>The interrupt prioritization in the NVIC allows higher priority interrupts to be handled before lower<br>priority interrupts, as well as allowing preemption of lower priority interrupt handlers by higher priority<br>interrupts. Again, this helps reduce interrupt response time (for example, a 1 ms system control<br>interrupt is not held off by the execution of a lower priority 1 second housekeeping interrupt handler).</p>
<blockquote>
<p>中断处理优先级使得高优先级的中断在低优先级中断之前处理，并允许高优先级中断抢占低优先级中断。这还能减少中断响应时间，比如1ms的系统控制中断不会被更低优先级的1ms中断所延迟。</p>
</blockquote>
<p>Sub-prioritization is also possible; instead of having N bits of preemptable prioritization, the NVIC<br>can be configured (via software) for N - M bits of preemptable prioritization and M bits of sub-priority.<br>In this scheme, two interrupts with the same preemptable prioritization but different sub-priorities<br>do not cause a preemption; tail chaining is used instead to process the two interrupts back-to-back.</p>
<blockquote>
<p>还可以设置子优先级，如果不设置N位可抢占优先级的话，可以通过软件设置N-M个可抢占优先级和M个子优先级，在这种方案下，两个仅仅子优先级不同的可抢占中断不会导致抢占，单片机会使用尾链来来回处理两个中断</p>
</blockquote>
<p>If two interrupts with the same priority (and sub-priority if so configured) are asserted at the same<br>time, the one with the lower interrupt number is processed first. The NVIC keeps track of the nesting<br>of interrupt handlers, allowing the processor to return from interrupt context only once all nested<br>and pending interrupts have been handled.</p>
<blockquote>
<p>如果两个中断有相同的优先级（和子优先级）还被同时触发了，中断数更低的有限执行，NVIC会跟踪中断处理程序的嵌套，要求处理器在处理完所有被嵌套和挂起的中断后再返回</p>
</blockquote>
<p>Interrupt handlers can be configured in one of two ways; statically at compile time or dynamically at<br>run time. Static configuration of interrupt handlers is accomplished by editing the interrupt handler<br>table in the application’s startup code. When statically configured, the interrupts must be explicitly<br>enabled in the NVIC via IntEnable() before the processor can respond to the interrupt (in addition to<br>any interrupt enabling required within the peripheral itself). Statically configuring the interrupt table<br>provides the fastest interrupt response time because the stacking operation (a write to SRAM) can<br>be performed in parallel with the interrupt handler table fetch (a read from Flash), as well as the<br>prefetch of the interrupt handler itself (assuming it is also in Flash).</p>
<blockquote>
<p>中断处理程序可以用两种方式中的一种来设置，编译时设置或者运行时动态设置。静态配置使用的是IntEnable（）函数完成的，运行的时候静态配置的中断处理程序更快一点。</p>
</blockquote>
<p>Alternatively, interrupts can be configured at run-time using IntRegister() (or the analog in each<br>individual driver). When using IntRegister(), the interrupt must also be enabled as before; when<br>using the analogue in each individual driver, IntEnable() is called by the driver and does not need<br>to be called by the application. Run-time configuration of interrupts adds a small latency to the<br>interrupt response time because the stacking operation (a write to SRAM) and the interrupt handler<br>table fetch (a read from SRAM) must be performed sequentially.</p>
<blockquote>
<p>在运行时设置的话，需要用到IntRegister()函数，会有延迟。</p>
</blockquote>
<p>Run-time configuration of interrupt handlers requires that the interrupt handler table be placed on a<br>1-kB boundary in SRAM (typically this is at the beginning of SRAM). Failure to do so results in an<br>incorrect vector address being fetched in response to an interrupt. The vector table is in a section<br>called “vtable” and must be placed appropriately with a linker script.</p>
<blockquote>
<p>中断处理程序的配置需要将中断处理表放在SARM1kb的边缘上。。。。。</p>
</blockquote>
<p>This driver is contained in driverlib/interrupt.c, with driverlib/interrupt.h containing<br>the API declarations for use by applications.</p>
<p>他的函数非常少</p>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212164149113.png" alt="image-20201212164149113"></p>
<p>前两个是使能/使不能一个中断</p>
<p>第三个 确认一个中断是否在运行，如果一个中断在运行的话，会返回一个非零数</p>
<p>第四个 第五个 使能/使不能处理器中断</p>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212164210385.png" alt="image-20201212164210385"></p>
<p>第一个 第二个 挂起/放下一个中断</p>
<p>第三个 获取一个中断的优先级</p>
<p>第四个 获取中断控制器的优先级分组 就是返回可抢占优先级的位数</p>
<p>第五个 设置可抢占优先级的位数</p>
<p>第六个 获取优先级屏蔽 </p>
<blockquote>
<p>This function gets the current setting of the interrupt priority masking level. The value returned is the priority level such that all interrupts of that and lesser priority are masked. A value of 0 means that priority masking is disabled.<br>Smaller numbers correspond to higher interrupt priorities. So for example a priority level mask of 4 allows interrupts of priority level 0-3, and interrupts with a numerical priority of 4 and greater are blocked.<br>The hardware priority mechanism only looks at the upper 3 bits of the priority level, so any prioritization must be performed in those bits.</p>
</blockquote>
<p>第七个 设置优先级屏蔽</p>
<p>第八个 设置中断优先级</p>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212165114559.png" alt="image-20201212165114559"></p>
<p>第一个 注册一个函数，中断发生是就调用它</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// UART 0 interrupt handler.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">UART0Handler(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Handle interrupt.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the UART 0 interrupt handler.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">IntRegister(INT_UART0, UART0Handler);</span><br></pre></td></tr></table></figure>
<p>第二个 触发一个中断 （直接触发）</p>
</blockquote>
<p>第三个 解注册一个中断</p>
<p>所以怎样使用中断呢？</p>
<p>直接去对应外设那里去查询中断怎样使用，然后回来使能中断即可，有需要就设置优先级啊，子优先级啊，屏蔽啊等等。</p>
<p>有需要还可以直接触发一个中断的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/Interrupt%20Controller(NVIC)/" data-id="ckmsxdddr000zjk3d6oneabod" data-title="中断控制器" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MIDI文件格式分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/MIDI%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/MIDI%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/">midi</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MIDI文件格式分析"><a href="#MIDI文件格式分析" class="headerlink" title="MIDI文件格式分析"></a>MIDI文件格式分析</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiankong_/article/details/78754545?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">感谢这个博客</a></p>
<h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><p>每一个MIDI文件的开头都有如下一段内容，4d 54 68 64 00 00 00 06 ff ff nn nn dd dd</p>
<p>前四个字节是ASCII字符MThd 表示这是一个Midi文件，</p>
<p>下面四个字节是指明文件头描述部分的字节数，一共是6，所以一定是00 00 00 06</p>
<p>下面是剩余部分的含义</p>
<p>ff ff指定Midi的格式</p>
<blockquote>
<p>00 00 表示单音轨</p>
<p>00 01表示多音轨同步（常见）</p>
<p>00 02表示多音轨不同步</p>
</blockquote>
<p>nn nn表示轨道数</p>
<blockquote>
<p>实际音轨倒数加上一个全局的音轨</p>
</blockquote>
<p>dd dd指定基本时间</p>
<blockquote>
<p>一般为120 （00 78）即一个四分音符的tick数，tick是MIDI中最小时间单位</p>
</blockquote>
<p>例如下面</p>
<blockquote>
<p>4d54 6864 0000 0006 0001 0003 01e0</p>
<p>表示这是一个MIDI文件 文件头描述部分占6字节 多音轨同步 一共3个音轨 基本时间是01e0（480）</p>
</blockquote>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>先来看全局音轨 全局音轨包括了歌曲的附加信息（比如标题和版权），歌曲速度和系统码等内容。</p>
<p>不论是全局音轨还是含有字符的音轨，都以4D 54 72 6B开头，表示”MTrk”后面跟着一个四个字节的整数，表示该音轨的字节数（不包括MTrk和本身的四个字节），然后是记录数据的地方。</p>
<p>每一个数据都有相同的结构：时间差+事件。</p>
<h5 id="时间差"><a href="#时间差" class="headerlink" title="时间差"></a>时间差</h5><p>所谓时间差，就是指从前一个事件到这个事件的时间数，单位是tick。一个字节有 8 位,如果仅使用 7 位,它可以表示 0~127 这 128 个数,而剩下的一位,则用来作为标志。(这一位被放在了每个字节的最前端）。如果要表示的数在以上范围,则这个标志为 0,这时,一个7 位的字节可以表示 0~127tick。如果要表示的数 超出了这个范围(比如 240),则把标志设置成 1,然后记录下高 7 位,剩下的留给下一个字节,在该例中 240 可以分解成 128<em> 1+112,这里的 1 就是第一个字节要记录的,加上标志位,应该为 10000001,即十六进制的 81;而 112 是下一个字节记录的,它的十六进制为 70:所以要表示 240 这个时间,要写成 81 70。 同理,如果要表示 65535tick,则可以先计算出65535=1282</em>3+1281<em>127+1280</em>127,然后得出结果:83 FF 7F。 由此,我们反过来也可以知道如何确定时间差:只要标志位为 0,则表示结束读取时间差。比如 82 C0 03 表示 1282<em>2+1281</em>64+1280*3=40963,如果基本时间为 120,则有 341:043 个四分音符。</p>
<p>以这种方式记录整数的字节称为动态字节,它根据记录的整数改变自身的长度,这在后面还要用到,所以 必须熟练计算。</p>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p>事件可以分为音符，控制器系统信息等几个种类，对于这些事件，都有统一的表达结构：种类+参数</p>
<p>对于一个音符，由于他的有效范围是0~127，所以直接用00~7F作为种类，也可以认为是个音符，比如3C表示中央C，而一个音符的最重要的参数是力度，比如，3C 64表示一个力度为100的中央C音符。</p>
<p>因为一个字节有8位，所以第一位如果置1，那么它就可以表示其他信息，</p>
<p>下表中,x 表示音轨 0~F,比如 81 表示松开第二轨的音符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>种类</th>
<th>参数(十六进制)</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>字节</td>
<td>含义</td>
<td></td>
</tr>
<tr>
<td>8x</td>
<td>松开音符</td>
<td>音符(00~7F):松开的音符</td>
</tr>
<tr>
<td>力度:00~7F</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9x</td>
<td>按下音符</td>
<td>音符(00~7F):按下的音符</td>
</tr>
<tr>
<td>力度:00~7F</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Ax</td>
<td>触后音符 (Key After Touch)</td>
<td>音符:00~7F</td>
</tr>
<tr>
<td>力度:00~7F</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Bx</td>
<td>控制器</td>
<td>控制器号码:00~7F</td>
</tr>
<tr>
<td>控制器参数:00~7F</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cx</td>
<td>改变乐器</td>
<td>乐器号码:00~7F</td>
</tr>
<tr>
<td>Dx</td>
<td>触后通道</td>
<td>值:00~7F</td>
</tr>
<tr>
<td>Ex</td>
<td>滑音</td>
<td>音高(Pitch)低位:Pitch mod 128</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>音高高位:Pitch div 128</th>
</tr>
</thead>
<tbody>
<tr>
<td>F0</td>
<td>系统码</td>
<td>系统码字节数:动态字节</td>
</tr>
<tr>
<td>系统码:不含开头的 F0,但包括结尾的 F7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FF</td>
<td>其他格式</td>
<td>程式种类:00~FF</td>
</tr>
<tr>
<td>数据占用的字节数:动态字节</td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据:个数由上一参数确定</td>
<td></td>
<td></td>
</tr>
<tr>
<td>00~7F</td>
<td>上次激活格式的参数(8x、9x、Ax、Bx、Cx、Dx、Ex)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>节拍器时钟</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>一个四分音符包含的三十二分音符的个数</td>
</tr>
<tr>
<td>59</td>
<td>调号</td>
<td>02</td>
<td>升降号数:-7~-1(降号),0(C),1~7(升号)</td>
</tr>
<tr>
<td>大小调:0(大调),1(小调)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7F</td>
<td>音序特定信息</td>
<td>—</td>
<td>音序特定信息</td>
</tr>
</tbody>
</table>
</div>
<p>下表详细地列出了 FF 的详细情况,对于字节数由数据决定的情况,表中以“—”表示。</p>
<p>种类 字 节</p>
<p>字节 含义<br>00 设置轨道音序</p>
<p>数据 数</p>
<p>02 音序号 00 00~ FF FF</p>
<p>01</p>
<p>歌曲备注 文本信息 —</p>
<p>音轨文本 文本信息</p>
<p>02 歌曲版权<br>歌曲标题 —</p>
<p>03</p>
<p>— 版权信息</p>
<p>歌曲标题:用于全局音轨,第一次使用表示主标题,第二次表 示副标题</p>
<p>音轨名称 — 音轨名</p>
<p>04 乐器名称</p>
<p>— 音轨文本(同 01/2)</p>
<p>05歌词 —歌词</p>
<p>06  标记</p>
<p>07  开始点</p>
<p>2F 音轨结束标志</p>
<p>51 速度</p>
<p>— 用文本标记(Marker)</p>
<p>— 用文本记录开始点(同 01/2)</p>
<p>00 无</p>
<p>03 3字节整数,1个四分音符的微秒数</p>
<p>58节拍 04分子</p>
<p>分母:00(1),01(2),02(4),03(8)等</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>节拍器时钟</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td>一个四分音符包含的三十二分音符的个数</td>
</tr>
<tr>
<td>59</td>
<td>调号</td>
<td>02</td>
<td>升降号数:-7~-1(降号),0(C),1~7(升号)</td>
</tr>
<tr>
<td>大小调:0(大调),1(小调)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7F</td>
<td>音序特定信息</td>
<td>—</td>
<td>音序特定信息</td>
</tr>
</tbody>
</table>
</div>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/MIDI%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/" data-id="ckmsxddds0013jk3d8vet0ogo" data-title="midi" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/midi/" rel="tag">midi</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/midi/" rel="tag">midi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stm32/" rel="tag">stm32</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/midi/" style="font-size: 10px;">midi</a> <a href="/tags/stm32/" style="font-size: 15px;">stm32</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 20px;">单片机</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/28/999-project/">stm32_template</a>
          </li>
        
          <li>
            <a href="/2021/03/27/004-USART/">stm32_USART</a>
          </li>
        
          <li>
            <a href="/2021/03/26/003-systick/">stm32-systick</a>
          </li>
        
          <li>
            <a href="/2021/03/23/002-GPIO/">stm32_GPIO</a>
          </li>
        
          <li>
            <a href="/2021/03/15/001-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B/">new project</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 smallcracker<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
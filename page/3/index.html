<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Welcome to smallcracker&#39;s personal website</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="联系方式：1426090870">
<meta property="og:type" content="website">
<meta property="og:title" content="Welcome to smallcracker&#39;s personal website">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Welcome to smallcracker&#39;s personal website">
<meta property="og:description" content="联系方式：1426090870">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="smallcracker">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Welcome to smallcracker's personal website" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Welcome to smallcracker&#39;s personal website</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Interrupt Controller(NVIC)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/Interrupt%20Controller(NVIC)/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/Interrupt%20Controller(NVIC)/">中断控制器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Interrupt-Controller-NVIC"><a href="#Interrupt-Controller-NVIC" class="headerlink" title="Interrupt Controller(NVIC)"></a>Interrupt Controller(NVIC)</h1><p>The interrupt controller API provides a set of functions for dealing with the Nested Vectored Interrupt<br>Controller (NVIC). Functions are provided to enable and disable interrupts, register interrupt<br>handlers, and set the priority of interrupts.</p>
<blockquote>
<p>中断控制器API提供了一系列与内置向量式中断控制器有关的函数，这些函数能使能/使不能中断，注册中断，设置中断优先级等</p>
</blockquote>
<p>The NVIC provides global interrupt masking, prioritization, and handler dispatching. Devices within<br>the Tiva family support up to 154 interrupt sources and eight priority levels. Individual interrupt<br>sources can be masked, and the processor interrupt can be globally masked as well (without affecting<br>the individual source masks).</p>
<blockquote>
<p>NVIC提供了全局中断屏蔽，优先级和处理器调度功能，在Tiva系列设备里至多支持154个中断和8个中断级，单个中断源可以被屏蔽，处理器屏蔽也可以被全局屏蔽（不影响单个中断源的屏蔽哦）</p>
</blockquote>
<p>The NVIC is tightly coupled with the Cortex-M microprocessor. When the processor responds to<br>an interrupt, the NVIC supplies the address of the function to handle the interrupt directly to the<br>processor. This action eliminates the need for a global interrupt handler that queries the interrupt<br>controller to determine the cause of the interrupt and branch to the appropriate handler, reducing<br>interrupt response time.</p>
<blockquote>
<p>NVIC紧密搭配着cortex_M微处理器。当处理器对中断作出反应时，NVIC直接把处理中断的函数的地址提供给处理器，此操作无需使用全局中断处理程序来查询中断控制器以确定中断的原因，并分支到相应的处理程序，从而减少中断响应时间。  </p>
</blockquote>
<p>The interrupt prioritization in the NVIC allows higher priority interrupts to be handled before lower<br>priority interrupts, as well as allowing preemption of lower priority interrupt handlers by higher priority<br>interrupts. Again, this helps reduce interrupt response time (for example, a 1 ms system control<br>interrupt is not held off by the execution of a lower priority 1 second housekeeping interrupt handler).</p>
<blockquote>
<p>中断处理优先级使得高优先级的中断在低优先级中断之前处理，并允许高优先级中断抢占低优先级中断。这还能减少中断响应时间，比如1ms的系统控制中断不会被更低优先级的1ms中断所延迟。</p>
</blockquote>
<p>Sub-prioritization is also possible; instead of having N bits of preemptable prioritization, the NVIC<br>can be configured (via software) for N - M bits of preemptable prioritization and M bits of sub-priority.<br>In this scheme, two interrupts with the same preemptable prioritization but different sub-priorities<br>do not cause a preemption; tail chaining is used instead to process the two interrupts back-to-back.</p>
<blockquote>
<p>还可以设置子优先级，如果不设置N位可抢占优先级的话，可以通过软件设置N-M个可抢占优先级和M个子优先级，在这种方案下，两个仅仅子优先级不同的可抢占中断不会导致抢占，单片机会使用尾链来来回处理两个中断</p>
</blockquote>
<p>If two interrupts with the same priority (and sub-priority if so configured) are asserted at the same<br>time, the one with the lower interrupt number is processed first. The NVIC keeps track of the nesting<br>of interrupt handlers, allowing the processor to return from interrupt context only once all nested<br>and pending interrupts have been handled.</p>
<blockquote>
<p>如果两个中断有相同的优先级（和子优先级）还被同时触发了，中断数更低的有限执行，NVIC会跟踪中断处理程序的嵌套，要求处理器在处理完所有被嵌套和挂起的中断后再返回</p>
</blockquote>
<p>Interrupt handlers can be configured in one of two ways; statically at compile time or dynamically at<br>run time. Static configuration of interrupt handlers is accomplished by editing the interrupt handler<br>table in the application’s startup code. When statically configured, the interrupts must be explicitly<br>enabled in the NVIC via IntEnable() before the processor can respond to the interrupt (in addition to<br>any interrupt enabling required within the peripheral itself). Statically configuring the interrupt table<br>provides the fastest interrupt response time because the stacking operation (a write to SRAM) can<br>be performed in parallel with the interrupt handler table fetch (a read from Flash), as well as the<br>prefetch of the interrupt handler itself (assuming it is also in Flash).</p>
<blockquote>
<p>中断处理程序可以用两种方式中的一种来设置，编译时设置或者运行时动态设置。静态配置使用的是IntEnable（）函数完成的，运行的时候静态配置的中断处理程序更快一点。</p>
</blockquote>
<p>Alternatively, interrupts can be configured at run-time using IntRegister() (or the analog in each<br>individual driver). When using IntRegister(), the interrupt must also be enabled as before; when<br>using the analogue in each individual driver, IntEnable() is called by the driver and does not need<br>to be called by the application. Run-time configuration of interrupts adds a small latency to the<br>interrupt response time because the stacking operation (a write to SRAM) and the interrupt handler<br>table fetch (a read from SRAM) must be performed sequentially.</p>
<blockquote>
<p>在运行时设置的话，需要用到IntRegister()函数，会有延迟。</p>
</blockquote>
<p>Run-time configuration of interrupt handlers requires that the interrupt handler table be placed on a<br>1-kB boundary in SRAM (typically this is at the beginning of SRAM). Failure to do so results in an<br>incorrect vector address being fetched in response to an interrupt. The vector table is in a section<br>called “vtable” and must be placed appropriately with a linker script.</p>
<blockquote>
<p>中断处理程序的配置需要将中断处理表放在SARM1kb的边缘上。。。。。</p>
</blockquote>
<p>This driver is contained in driverlib/interrupt.c, with driverlib/interrupt.h containing<br>the API declarations for use by applications.</p>
<p>他的函数非常少</p>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212164149113.png" alt="image-20201212164149113"></p>
<p>前两个是使能/使不能一个中断</p>
<p>第三个 确认一个中断是否在运行，如果一个中断在运行的话，会返回一个非零数</p>
<p>第四个 第五个 使能/使不能处理器中断</p>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212164210385.png" alt="image-20201212164210385"></p>
<p>第一个 第二个 挂起/放下一个中断</p>
<p>第三个 获取一个中断的优先级</p>
<p>第四个 获取中断控制器的优先级分组 就是返回可抢占优先级的位数</p>
<p>第五个 设置可抢占优先级的位数</p>
<p>第六个 获取优先级屏蔽 </p>
<blockquote>
<p>This function gets the current setting of the interrupt priority masking level. The value returned is the priority level such that all interrupts of that and lesser priority are masked. A value of 0 means that priority masking is disabled.<br>Smaller numbers correspond to higher interrupt priorities. So for example a priority level mask of 4 allows interrupts of priority level 0-3, and interrupts with a numerical priority of 4 and greater are blocked.<br>The hardware priority mechanism only looks at the upper 3 bits of the priority level, so any prioritization must be performed in those bits.</p>
</blockquote>
<p>第七个 设置优先级屏蔽</p>
<p>第八个 设置中断优先级</p>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212165114559.png" alt="image-20201212165114559"></p>
<p>第一个 注册一个函数，中断发生是就调用它</p>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// UART 0 interrupt handler.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">UART0Handler(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Handle interrupt.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the UART 0 interrupt handler.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">IntRegister(INT_UART0, UART0Handler);</span><br></pre></td></tr></table></figure>
<p>第二个 触发一个中断 （直接触发）</p>
</blockquote>
<p>第三个 解注册一个中断</p>
<p>所以怎样使用中断呢？</p>
<p>直接去对应外设那里去查询中断怎样使用，然后回来使能中断即可，有需要就设置优先级啊，子优先级啊，屏蔽啊等等。</p>
<p>有需要还可以直接触发一个中断的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/Interrupt%20Controller(NVIC)/" data-id="cklymn3pz000p083dh3reg8ql" data-title="中断控制器" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-TIMER_CAPTURE" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/TIMER_CAPTURE/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/TIMER_CAPTURE/">Timer Capture</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="TIMER-CAPTURE"><a href="#TIMER-CAPTURE" class="headerlink" title="TIMER_CAPTURE"></a>TIMER_CAPTURE</h1><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>计时器模块可以捕捉io脚的电平边沿，硬件上要求电平保持时间大于两个时钟周期，在这个模式下，技术范围扩展到24/48位</p>
<p>计数值可以为加计数、减计数，加计数的范围是零到预设值，减计数是Preload到预设值。</p>
<p>加计数和减计数的另一个差异是计数终止时的差异，加计数模式下，计数器会自动清零重新计数，减计数模式下，计数器会恢复preload值，但是会停止计数，需要重新使能。</p>
<h3 id="功能一，边沿计数"><a href="#功能一，边沿计数" class="headerlink" title="功能一，边沿计数"></a>功能一，边沿计数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line">    GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3);</span><br><span class="line">    GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer2AIntHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ulstatus = TimerIntStatus(TIMER2_BASE, TIMER_CAPA_MATCH | TIMER_CAPB_MATCH);</span><br><span class="line">    TimerIntClear(TIMER2_BASE, ulstatus);</span><br><span class="line">        t++;</span><br><span class="line">        <span class="keyword">if</span>(t%<span class="number">2</span>)&#123;</span><br><span class="line">            GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIO_ccp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使能GPIO时钟</span></span><br><span class="line">    <span class="comment">//SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span></span><br><span class="line">    <span class="comment">//使能Timer模块</span></span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER2);</span><br><span class="line">    <span class="comment">//配置GPIO引脚为Timer捕捉模式</span></span><br><span class="line">    GPIOPinConfigure(GPIO_PF4_T2CCP0);</span><br><span class="line">    GPIOPinTypeTimer(GPIO_PORTF_BASE, GPIO_PIN_4);</span><br><span class="line">    <span class="comment">//配置管脚为弱上拉模式</span></span><br><span class="line">    GPIOPadConfigSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);</span><br><span class="line">    <span class="comment">//配置Timer的A模块为边沿触发 加计数模式</span></span><br><span class="line">    TimerConfigure(TIMER2_BASE, TIMER_CFG_SPLIT_PAIR | TIMER_CFG_A_CAP_COUNT_UP);</span><br><span class="line">    <span class="comment">//设置下降沿触发</span></span><br><span class="line">    TimerControlEvent(TIMER2_BASE, TIMER_A, TIMER_EVENT_POS_EDGE);</span><br><span class="line">    TimerMatchSet(TIMER2_BASE, TIMER_A, <span class="number">3</span>);</span><br><span class="line">    TimerIntRegister(TIMER2_BASE, TIMER_A, Timer2AIntHandler);</span><br><span class="line">    IntMasterEnable();</span><br><span class="line">    TimerIntEnable(TIMER2_BASE, TIMER_CAPA_MATCH);</span><br><span class="line">    IntEnable(INT_TIMER2A);</span><br><span class="line">    TimerEnable(TIMER2_BASE,TIMER_A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="功能二，边沿计时"><a href="#功能二，边沿计时" class="headerlink" title="功能二，边沿计时"></a>功能二，边沿计时</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer2AIntHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s=TimerIntStatus(TIMER2_BASE,TIMER_CAPA_EVENT);</span><br><span class="line">    TimerIntClear(TIMER2_BASE,s);</span><br><span class="line">    UARTprintf(<span class="string">&quot;Captured Value: 0x%04X\n&quot;</span>, TimerValueGet(TIMER2_BASE, TIMER_A));</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TIMER_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使能定时器和GPIO</span></span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER2);</span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line">    <span class="comment">//配置GPIO引脚为timer捕捉模式</span></span><br><span class="line">    GPIOPinConfigure(GPIO_PF4_T2CCP0);</span><br><span class="line">    GPIOPinTypeTimer(GPIO_PORTF_BASE, GPIO_PIN_4);</span><br><span class="line">    <span class="comment">//配置管脚为弱上拉模式</span></span><br><span class="line">    GPIOPadConfigSet(GPIO_PORTF_BASE, GPIO_PIN_4, GPIO_STRENGTH_2MA, GPIO_PIN_TYPE_STD_WPU);</span><br><span class="line">    <span class="comment">//配置Timer模块为沿触发加计时模式</span></span><br><span class="line">    TimerConfigure(TIMER2_BASE, TIMER_CFG_SPLIT_PAIR | TIMER_CFG_A_CAP_TIME_UP);</span><br><span class="line">    <span class="comment">//使用下降沿触发</span></span><br><span class="line">    TimerControlEvent(TIMER2_BASE, TIMER_A, TIMER_EVENT_NEG_EDGE);</span><br><span class="line">    <span class="comment">//设置计数范围</span></span><br><span class="line">    TimerLoadSet(TIMER2_BASE, TIMER_A, <span class="number">0x8FFF</span>);</span><br><span class="line">    <span class="comment">//注册定时器中断</span></span><br><span class="line">    TimerIntRegister(TIMER2_BASE, TIMER_A, Timer2AIntHandler);</span><br><span class="line">    <span class="comment">//使能中断，定时器，定时器中断</span></span><br><span class="line">    IntMasterEnable();</span><br><span class="line">    TimerIntEnable(TIMER2_BASE, TIMER_CAPA_EVENT);</span><br><span class="line">    IntEnable(INT_TIMER2A);</span><br><span class="line">    TimerEnable(TIMER2_BASE,TIMER_A);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/TIMER_CAPTURE/" data-id="cklymn3pz000r083dh2d22t27" data-title="Timer Capture" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MIDI文件格式分析" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/MIDI%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/MIDI%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/">midi</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MIDI文件格式分析"><a href="#MIDI文件格式分析" class="headerlink" title="MIDI文件格式分析"></a>MIDI文件格式分析</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tiankong_/article/details/78754545?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">感谢这个博客</a></p>
<h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><p>每一个MIDI文件的开头都有如下一段内容，4d 54 68 64 00 00 00 06 ff ff nn nn dd dd</p>
<p>前四个字节是ASCII字符MThd 表示这是一个Midi文件，</p>
<p>下面四个字节是指明文件头描述部分的字节数，一共是6，所以一定是00 00 00 06</p>
<p>下面是剩余部分的含义</p>
<p>ff ff指定Midi的格式</p>
<blockquote>
<p>00 00 表示单音轨</p>
<p>00 01表示多音轨同步（常见）</p>
<p>00 02表示多音轨不同步</p>
</blockquote>
<p>nn nn表示轨道数</p>
<blockquote>
<p>实际音轨倒数加上一个全局的音轨</p>
</blockquote>
<p>dd dd指定基本时间</p>
<blockquote>
<p>一般为120 （00 78）即一个四分音符的tick数，tick是MIDI中最小时间单位</p>
</blockquote>
<p>例如下面</p>
<blockquote>
<p>4d54 6864 0000 0006 0001 0003 01e0</p>
<p>表示这是一个MIDI文件 文件头描述部分占6字节 多音轨同步 一共3个音轨 基本时间是01e0（480）</p>
</blockquote>
<h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>先来看全局音轨 全局音轨包括了歌曲的附加信息（比如标题和版权），歌曲速度和系统码等内容。</p>
<p>不论是全局音轨还是含有字符的音轨，都以4D 54 72 6B开头，表示”MTrk”后面跟着一个四个字节的整数，表示该音轨的字节数（不包括MTrk和本身的四个字节），然后是记录数据的地方。</p>
<p>每一个数据都有相同的结构：时间差+事件。</p>
<h5 id="时间差"><a href="#时间差" class="headerlink" title="时间差"></a>时间差</h5><p>所谓时间差，就是指从前一个事件到这个事件的时间数，单位是tick。一个字节有 8 位,如果仅使用 7 位,它可以表示 0~127 这 128 个数,而剩下的一位,则用来作为标志。(这一位被放在了每个字节的最前端）。如果要表示的数在以上范围,则这个标志为 0,这时,一个7 位的字节可以表示 0~127tick。如果要表示的数 超出了这个范围(比如 240),则把标志设置成 1,然后记录下高 7 位,剩下的留给下一个字节,在该例中 240 可以分解成 128<em> 1+112,这里的 1 就是第一个字节要记录的,加上标志位,应该为 10000001,即十六进制的 81;而 112 是下一个字节记录的,它的十六进制为 70:所以要表示 240 这个时间,要写成 81 70。 同理,如果要表示 65535tick,则可以先计算出65535=1282</em>3+1281<em>127+1280</em>127,然后得出结果:83 FF 7F。 由此,我们反过来也可以知道如何确定时间差:只要标志位为 0,则表示结束读取时间差。比如 82 C0 03 表示 1282<em>2+1281</em>64+1280*3=40963,如果基本时间为 120,则有 341:043 个四分音符。</p>
<p>以这种方式记录整数的字节称为动态字节,它根据记录的整数改变自身的长度,这在后面还要用到,所以 必须熟练计算。</p>
<h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><p>事件可以分为音符，控制器系统信息等几个种类，对于这些事件，都有统一的表达结构：种类+参数</p>
<p>对于一个音符，由于他的有效范围是0~127，所以直接用00~7F作为种类，也可以认为是个音符，比如3C表示中央C，而一个音符的最重要的参数是力度，比如，3C 64表示一个力度为100的中央C音符。</p>
<p>因为一个字节有8位，所以第一位如果置1，那么它就可以表示其他信息，</p>
<p>下表中,x 表示音轨 0~F,比如 81 表示松开第二轨的音符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>种类</th>
<th>参数(十六进制)</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>字节</td>
<td>含义</td>
<td></td>
</tr>
<tr>
<td>8x</td>
<td>松开音符</td>
<td>音符(00~7F):松开的音符</td>
</tr>
<tr>
<td>力度:00~7F</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9x</td>
<td>按下音符</td>
<td>音符(00~7F):按下的音符</td>
</tr>
<tr>
<td>力度:00~7F</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Ax</td>
<td>触后音符 (Key After Touch)</td>
<td>音符:00~7F</td>
</tr>
<tr>
<td>力度:00~7F</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Bx</td>
<td>控制器</td>
<td>控制器号码:00~7F</td>
</tr>
<tr>
<td>控制器参数:00~7F</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Cx</td>
<td>改变乐器</td>
<td>乐器号码:00~7F</td>
</tr>
<tr>
<td>Dx</td>
<td>触后通道</td>
<td>值:00~7F</td>
</tr>
<tr>
<td>Ex</td>
<td>滑音</td>
<td>音高(Pitch)低位:Pitch mod 128</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>音高高位:Pitch div 128</th>
</tr>
</thead>
<tbody>
<tr>
<td>F0</td>
<td>系统码</td>
<td>系统码字节数:动态字节</td>
</tr>
<tr>
<td>系统码:不含开头的 F0,但包括结尾的 F7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FF</td>
<td>其他格式</td>
<td>程式种类:00~FF</td>
</tr>
<tr>
<td>数据占用的字节数:动态字节</td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据:个数由上一参数确定</td>
<td></td>
<td></td>
</tr>
<tr>
<td>00~7F</td>
<td>上次激活格式的参数(8x、9x、Ax、Bx、Cx、Dx、Ex)</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>节拍器时钟</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>一个四分音符包含的三十二分音符的个数</td>
</tr>
<tr>
<td>59</td>
<td>调号</td>
<td>02</td>
<td>升降号数:-7~-1(降号),0(C),1~7(升号)</td>
</tr>
<tr>
<td>大小调:0(大调),1(小调)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7F</td>
<td>音序特定信息</td>
<td>—</td>
<td>音序特定信息</td>
</tr>
</tbody>
</table>
</div>
<p>下表详细地列出了 FF 的详细情况,对于字节数由数据决定的情况,表中以“—”表示。</p>
<p>种类 字 节</p>
<p>字节 含义<br>00 设置轨道音序</p>
<p>数据 数</p>
<p>02 音序号 00 00~ FF FF</p>
<p>01</p>
<p>歌曲备注 文本信息 —</p>
<p>音轨文本 文本信息</p>
<p>02 歌曲版权<br>歌曲标题 —</p>
<p>03</p>
<p>— 版权信息</p>
<p>歌曲标题:用于全局音轨,第一次使用表示主标题,第二次表 示副标题</p>
<p>音轨名称 — 音轨名</p>
<p>04 乐器名称</p>
<p>— 音轨文本(同 01/2)</p>
<p>05歌词 —歌词</p>
<p>06  标记</p>
<p>07  开始点</p>
<p>2F 音轨结束标志</p>
<p>51 速度</p>
<p>— 用文本标记(Marker)</p>
<p>— 用文本记录开始点(同 01/2)</p>
<p>00 无</p>
<p>03 3字节整数,1个四分音符的微秒数</p>
<p>58节拍 04分子</p>
<p>分母:00(1),01(2),02(4),03(8)等</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th>节拍器时钟</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td></td>
<td>一个四分音符包含的三十二分音符的个数</td>
</tr>
<tr>
<td>59</td>
<td>调号</td>
<td>02</td>
<td>升降号数:-7~-1(降号),0(C),1~7(升号)</td>
</tr>
<tr>
<td>大小调:0(大调),1(小调)</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7F</td>
<td>音序特定信息</td>
<td>—</td>
<td>音序特定信息</td>
</tr>
</tbody>
</table>
</div>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/MIDI%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/" data-id="cklymn3q0000t083db313awn7" data-title="midi" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/midi/" rel="tag">midi</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Pulse Width Modulator" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/Pulse%20Width%20Modulator/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/Pulse%20Width%20Modulator/">PWM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Each instance of a Tiva PWM module provides up to four instances of a PWM generator block, and an output control block. Each generator block has two PWM output signals, which can be operated independently or as a pair of signals with dead band delays inserted. Each generator block also has an interrupt output and a trigger output. The control block determines the polarity of the PWM signals and which signals are passed through to the pins.</p>
<blockquote>
<p>每个PWM提供了最多4个PWM发生器和一个输出控制模块，每一个发生器能产生两个PWM输出信号，可以独立操作，也可以作为一对插入了死区延迟的信号运行。每一个生成器块还有一个中断输出和一个触发输出，控制块确定PWM信号的极性以及哪些信号传递到引脚。</p>
</blockquote>
<p>Some of the features of the Tiva PWM module are:<br>Up to four generator blocks, each containing<br>• One 16-bit down or up/down counter<br>• Two comparators<br>• PWM generator<br>• Dead band generator</p>
<blockquote>
<p>至多4个产生模块，每一个产生模块包括</p>
<blockquote>
<p>一个十六位的向上/向下计数器</p>
<p>两个比较器</p>
<p>PWM产生器</p>
<p>死区产生器</p>
</blockquote>
</blockquote>
<p>Control block<br>• PWM output enable<br>• Output polarity control<br>• Synchronization<br>• Fault handling<br>• Interrupt status</p>
<blockquote>
<p>控制模块有</p>
<blockquote>
<p>PWM输出使能</p>
<p>输出极性控制</p>
<p>错误处理</p>
<p>中断状态</p>
</blockquote>
</blockquote>
<p>This driver is contained in driverlib/pwm.c, with driverlib/pwm.h containing the API declarations for use by applications.</p>
<h2 id="细节描述"><a href="#细节描述" class="headerlink" title="细节描述"></a>细节描述</h2><p>These functions perform high-level operations on PWM modules.</p>
<blockquote>
<p>这些模块表现了高水平的对PWM的操作</p>
</blockquote>
<p>The following functions provide the user with a way to configure the PWM for the most common operations, such as setting the period, generating left- and center-aligned pulses, modifying the pulse width, and controlling interrupts, triggers, and output characteristics. However, the PWM module is very versatile and can be configured in a number of different ways, many of which are beyond the scope of this API. In order to fully exploit the many features of the PWM module, users are advised to use register access macros.</p>
<blockquote>
<p>接下来的函数为用户提供了一种配置PWM做最普通操作的方式，这些操作有设定周期，产生左对齐/中心对齐的脉冲，调节脉冲宽度，控制中断/触发/输出特征等功能。然而，PWM模块非常的强大，可以用很多种方式设置，许多用的都不是这些API。为了能充分利用PWM模块的诸多功能，我们推荐用户使用寄存器。</p>
</blockquote>
<p>When discussing the various components of a PWM module, this API uses the following labeling convention:</p>
<p>The generator blocks are called Gen0, Gen1, Gen2 and Gen3.</p>
<blockquote>
<p>产生器模块被称为Gen0, Gen1, Gen2 and Gen3.</p>
</blockquote>
<p>The two PWM output signals associated with each generator block are called OutA and OutB.</p>
<blockquote>
<p>与产生器模块相关的两个PWM输出信号被称为OutA和OutB</p>
</blockquote>
<p>The output signals are called PWM0, PWM1, PWM2, PWM3, PWM4, PWM5, PWM6 and PWM7.</p>
<blockquote>
<p>输出信号被称为PWM0, PWM1, PWM2, PWM3, PWM4, PWM5, PWM6 and PWM7.</p>
</blockquote>
<p>PWM0 and PWM1 are associated with Gen0, PWM2 and PWM3 are associated with Gen1, PWM4 and PWM5 are associated with Gen2 and PWM6 and PWM7 are associated with Gen3.</p>
<blockquote>
<p>PWM0和PWM1与Gen0相关联，PWM2和PWM3与Gen1相关联，PWM4和PWM5与Gen2相关联，PWM6和PWM7与Gen3相关联。</p>
</blockquote>
<p>Also, as a simplifying assumption for this API, comparator A for each generator block is used exclusively to adjust the pulse width of the even numbered PWM outputs (PWM0, PWM2, PWM4 and PWM6). In addition, comparator B is used exclusively for the odd numbered PWM outputs (PWM1, PWM3, PWM5 and PWM7).<br>Note that the number of generators and PWM outputs supported varies depending upon the Tiva part in use. Please consult the datasheet for the part you are using to determine whether it supports 1 or 2 modules with 3 or 4 generators each and 6 or 8 outputs each. </p>
<blockquote>
<p>另外，作为对此API的简化假设，每个生成器模块的比较器仅用于调整偶数个PWM输出的脉冲高度，比较器A仅用于计数PWM输出</p>
<p>请注意，支持的生成器和 PWM 输出的数量因使用的 Tiva 部件而异。请参阅您使用的部件的数据表，以确定它是否支持 1 个或 2 个模块，每个模块有 3 个或 4 个生成器，每个模块有 6 个或 8 个输出。</p>
</blockquote>
<p><strong>我们这款单片机包括两个PWM模块，总共有16个输出</strong></p>
<p>这次我们直接看例程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Enable the PWM0 peripheral</span></span><br><span class="line"><span class="comment">// 使能PWM外设</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_PWM0);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Wait for the PWM0 module to be ready.</span></span><br><span class="line"><span class="comment">// 等待PWM模块准备好</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">while</span>(!SysCtlPeripheralReady(SYSCTL_PERIPH_PWM0))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Configure the PWM generator for count down mode with immediate updates</span></span><br><span class="line"><span class="comment">// to the parameters.</span></span><br><span class="line"><span class="comment">// 配置PWM产生器，并设置器为向下计数模式，和非同步模式</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMGenConfigure(PWM_BASE, PWM_GEN_0,PWM_GEN_MODE_DOWN | PWM_GEN_MODE_NO_SYNC);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the period. For a 50 KHz frequency, the period = 1/50,000, or 20</span></span><br><span class="line"><span class="comment">// microseconds. For a 20 MHz clock, this translates to 400 clock ticks.</span></span><br><span class="line"><span class="comment">// Use this value to set the period.</span></span><br><span class="line"><span class="comment">// 设置周期。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMGenPeriodSet(PWM_BASE, PWM_GEN_0, <span class="number">400</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the pulse width of PWM0 for a 25% duty cycle.</span></span><br><span class="line"><span class="comment">// 脉冲宽度设置</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMPulseWidthSet(PWM_BASE, PWM_OUT_0, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Set the pulse width of PWM1 for a 75% duty cycle.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMPulseWidthSet(PWM_BASE, PWM_OUT_1, <span class="number">300</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Start the timers in generator 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMGenEnable(PWM_BASE, PWM_GEN_0);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Enable the outputs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">PWMOutputState(PWM_BASE, (PWM_OUT_0_BIT | PWM_OUT_1_BIT), <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h2 id="关注如下函数"><a href="#关注如下函数" class="headerlink" title="关注如下函数"></a>关注如下函数</h2><h4 id="PWMGenConfigure"><a href="#PWMGenConfigure" class="headerlink" title="PWMGenConfigure"></a>PWMGenConfigure</h4><p>用于配置PWM</p>
<p>This function is used to set the mode of operation for a PWM generator. The counting mode, synchronization mode, and debug behavior are all configured. After configuration, the generator is left in the disabled state.</p>
<blockquote>
<p>这个函数用于设置PWM产生器的操作模式。计数模式，同步模式，调试模式都在这里设置。设置之后，产生器处于关闭状态。</p>
</blockquote>
<p>A PWM generator can count in two different modes: count down mode or count up/down mode. In count down mode, it counts from a value down to zero, and then resets to the preset value, producing left-aligned PWM signals (that is, the rising edge of the two PWM signals produced by the generator occur at the same time). In count up/down mode, it counts up from zero to the preset value, counts back down to zero, and then repeats the process, producing centeraligned PWM signals (that is, the middle of the high/low period of the PWM signals produced by the generator occurs at the same time).</p>
<blockquote>
<p>PWM产生器可以用两种计数模式计数，向下计数模式和向上/向下计数模式。</p>
<p>在向下计数模式中，它从一个值向下数到零，然后恢复到预设值，产生一个左对齐的PWM信号（也就是说，两个产生器产生的信号的升边同时出现）在向上向下计数模式中，它从零数到预设值，再数回到零，反复这个过程，产生的是中心对齐的PWM信号（也就是说，产生器产生的PWM信号的周期的中间时刻是同时发生的）<strong>每个生成器不是能产生两个PWM信号嘛</strong></p>
</blockquote>
<p>When the PWM generator parameters (period and pulse width) are modified, their effect on the output PWM signals can be delayed. In synchronous mode, the parameter updates are not applied until a synchronization event occurs. This mode allows multiple parameters to be modified and take effect simultaneously, instead of one at a time. Additionally, parameters to multiple PWM generators in synchronous mode can be updated simultaneously, allowing them to be treated as if they were a unified generator. In non-synchronous mode, the parameter updates are not delayed until a synchronization event. In either mode, the parameter updates only occur when the counter is at zero to help prevent oddly formed PWM signals during the update (that is, a PWM pulse that is too short or too long).</p>
<blockquote>
<p>当PWM脉冲产生器的参数（周期和脉冲宽度）被修改时，它们对PWM信号的影响可能会延迟。</p>
<p>在同步模式下，直到发生同步时间时应用参数才被更新。此模式允许多个参数同时修改并生效，而不是一次一个参数。此外，同步模式下多个 PWM 生成器的参数可以同时更新，从而可以将它们视为统一生成器。</p>
<p>在非同步模式下，参数 更新不会延迟到同步事件，在任意模式下，参数更新仅在计数器为零时在会发生，用以防止更新期间产生奇怪的PWM信号。</p>
</blockquote>
<p>The PWM generator can either pause or continue running when the processor is stopped via the debugger. If configured to pause, it continues to count until it reaches zero, at which point it pauses until the processor is restarted. If configured to continue running, it keeps counting as if nothing had happened.</p>
<blockquote>
<p>当调试器使处理器停止时，PWM产生器可以停止/继续运行如果配置为暂停，则它将继续计数，直到达到零，此时它会暂停，直到重新启动处理器。如果配置为继续运行，则继续计数，就像什么都没发生一样。</p>
</blockquote>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212211525865.png" alt="image-20201212211525865"></p>
<p>这是这个函数的参数，第一部分是PWM模块的基址，第二部分是PWM产生器，究竟是GEN几，最后是配置参数。</p>
<p>那么有哪些参数呢？</p>
<p>PWM_GEN_MODE_DOWN or PWM_GEN_MODE_UP_DOWN to specify the counting<br>mode</p>
<p><strong>计数模式，就是向上模式还是向上向下模式</strong></p>
<p>PWM_GEN_MODE_SYNC or PWM_GEN_MODE_NO_SYNC to specify the counter load<br>and comparator update synchronization mode</p>
<p><strong>不晓得</strong></p>
<p>PWM_GEN_MODE_DBG_RUN or PWM_GEN_MODE_DBG_STOP to specify the debug<br>behavior</p>
<p><strong>配置了debug的行为</strong></p>
<p>PWM_GEN_MODE_GEN_NO_SYNC, PWM_GEN_MODE_GEN_SYNC_LOCAL, or<br>PWM_GEN_MODE_GEN_SYNC_GLOBAL to specify the update synchronization mode<br>for generator counting mode changes</p>
<p><strong>不晓得</strong></p>
<p>PWM_GEN_MODE_DB_NO_SYNC, PWM_GEN_MODE_DB_SYNC_LOCAL, or<br>PWM_GEN_MODE_DB_SYNC_GLOBAL to specify the deadband parameter synchronization<br>mode</p>
<p><strong>指定死区参数同步模式</strong></p>
<p>PWM_GEN_MODE_FAULT_LATCHED or PWM_GEN_MODE_FAULT_UNLATCHED to<br>specify whether fault conditions are latched or not</p>
<p><strong>指定是否锁定故障条件</strong></p>
<p>PWM_GEN_MODE_FAULT_MINPER or PWM_GEN_MODE_FAULT_NO_MINPER to<br>specify whether minimum fault period support is required</p>
<p><strong>确定是否需要最小错误周期支持</strong></p>
<p>PWM_GEN_MODE_FAULT_EXT or PWM_GEN_MODE_FAULT_LEGACY to specify<br>whether extended fault source selection support is enabled or not</p>
<p><strong>指定是否启用扩展故障源选择支持</strong></p>
<!--死区就是中性区或者是不作用区-->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/Pulse%20Width%20Modulator/" data-id="cklymn3q1000v083d14hs34zv" data-title="PWM" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-System Tick" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/System%20Tick/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/System%20Tick/">SysTick</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SysTick"><a href="#SysTick" class="headerlink" title="SysTick"></a>SysTick</h1><p>SysTick is a simple timer that is part of the NVIC controller in the Cortex-M microprocessor. Its<br>intended purpose is to provide a periodic interrupt for an RTOS, but it can be used for other simple<br>timing purposes.<br>The SysTick interrupt handler does not need to clear the SysTick interrupt source as it is cleared<br>automatically by the NVIC when the SysTick interrupt handler is called.<br>This driver is contained in driverlib/systick.c, with driverlib/systick.h containing the<br>API declarations for use by applications.</p>
<p>大概的翻译一下</p>
<p>SysTick是一个简单的定时器，是Cortex-M微处理器中NVIXC控制器的一部分。他的目的在于为RTOS提供一个周期性的中断，也可以被用于其他简单的计时目的。</p>
<p>Systick 中断处理不需要清除Sys tick中断源，当SysTick中断处理被调用时NVIC会自动清理中断源。</p>
<p>头文件是driverlib/systick.h</p>
<p>The SysTick API is fairly simple, like SysTick itself. There are functions for configuring and enabling<br>SysTick (SysTickEnable(), SysTickDisable(), SysTickPeriodSet(), SysTickPeriodGet(), and<br>SysTickValueGet()) and functions for dealing with an interrupt handler for SysTick (SysTickIntRegister(),<br>SysTickIntUnregister(), SysTickIntEnable(), and SysTickIntDisable()).</p>
<p>他所包含的函数也特别少</p>
<p>主要有设置和使能函数还有处理中断的函数</p>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212171840774.png" alt="image-20201212171840774"></p>
<p>设置和使能的函数有</p>
<p>(SysTickEnable(), SysTickDisable(), SysTickPeriodSet(), SysTickPeriodGet(), and<br>SysTickValueGet())</p>
<p>先看头两个SysTickEnable(), SysTickDisable(), 使能和停止SysTick</p>
<p>如果中断处理已经注册，那就等中断重启时再停止。</p>
<p>其中SysTickEnable还有个note</p>
<blockquote>
<p>Calling this function causes the SysTick counter to (re)commence counting from its current<br>value. The counter is not automatically reloaded with the period as specified in a previous call<br>to SysTickPeriodSet(). If an immediate reload is required, the NVIC_ST_CURRENT register<br>must be written to force the reload. Any write to this register clears the SysTick counter to 0<br>and causes a reload with the supplied period on the next clock.</p>
</blockquote>
<p>上面是使能定时器的函数，接下来是使能定时器中断的函数SysTickIntEnable(), and SysTickIntDisable()</p>
<p>然后时注册/去除注册的函数SysTickIntRegister(),SysTickIntUnregister(),</p>
<p>其中SysTickIntRegister(),的参数是一个函数指针，表示中断发生时要调用的函数</p>
<p>还有两个函数能设置/返回计时器周期</p>
<p>周期可以设置在1到16777216之间，单位是处理器的时钟数</p>
<p>最后一个函数是获取定时器counter的函数SysTickValueGet()</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/System%20Tick/" data-id="cklymn3q2000y083d5cjy98of" data-title="SysTick" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-UART" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/UART/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/UART/">UART</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h1><p>UART能干什么？</p>
<p>能用来通信。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wxc971231/article/details/95624942?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.control">感谢这个人的博客</a></p>
<h3 id="基本功能-向上位机输出一个字符"><a href="#基本功能-向上位机输出一个字符" class="headerlink" title="基本功能 向上位机输出一个字符"></a>基本功能 向上位机输出一个字符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使能UART和GPIO</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);</span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);</span><br><span class="line"><span class="comment">//复用GPIO口为UART功能</span></span><br><span class="line">GPIOPinConfigure(GPIO_PA0_U0RX);</span><br><span class="line">GPIOPinConfigure(GPIO_PA1_U0TX);</span><br><span class="line">GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);</span><br><span class="line"><span class="comment">//设置UART组、频率、波特率、模式</span></span><br><span class="line">UARTConfigSetExpClk(UART0_BASE, SysCtlClockGet(), <span class="number">115200</span>, (UART_CONFIG_WLEN_8 | UART_CONFIG_STOP_ONE | UART_CONFIG_PAR_NONE));</span><br><span class="line"><span class="comment">//输出字符</span></span><br><span class="line">UARTCharPut(UART0_BASE, <span class="string">&#x27;E&#x27;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>模式说明：The ui32Config parameter is the logical OR of three values: the number of data bits, the number of stop bits, and the parity. UART_CONFIG_WLEN_8, UART_CONFIG_WLEN_7, UART_CONFIG_WLEN_6, and UART_CONFIG_WLEN_5 select from eight to five data bits per byte (respectively). UART_CONFIG_STOP_ONE and UART_CONFIG_STOP_TWO select one or two stop bits (respectively). UART_CONFIG_PAR_NONE, UART_CONFIG_PAR_EVEN, UART_CONFIG_PAR_ODD, UART_CONFIG_PAR_ONE, and UART_CONFIG_PAR_ZERO select the parity mode (no parity bit, even parity bit, odd parity bit, parity bit always one, and parity bit always zero,<br>respectively).</p>
<p>就是设置每一个byte有多少数据位，多长停止位，多长奇偶校验位</p>
</blockquote>
<h3 id="进阶功能-格式化输出到上位机"><a href="#进阶功能-格式化输出到上位机" class="headerlink" title="进阶功能 格式化输出到上位机"></a>进阶功能 格式化输出到上位机</h3><ul>
<li>UART时钟、波特率配置函数需要从<code>UARTConfigSetExpClk</code>变为<code>UARTStdioConfig</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使能外设</span></span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_UART1);</span><br><span class="line">SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置复用功能</span></span><br><span class="line">GPIOPinConfigure(GPIO_PB0_U1RX);</span><br><span class="line">GPIOPinConfigure(GPIO_PB1_U1TX);</span><br><span class="line"></span><br><span class="line"><span class="comment">//分配UART信号</span></span><br><span class="line">GPIOPinTypeUART(GPIO_PORTB_BASE,GPIO_PIN_0|GPIO_PIN_1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置UART参数(这样配置可以用UARTprintf)</span></span><br><span class="line">UARTClockSourceSet(UART1_BASE, UART_CLOCK_PIOSC);	</span><br><span class="line"><span class="comment">//使用16MHz内部高精度振荡器(PIOSC)作为UART模块时钟</span></span><br><span class="line">UARTStdioConfig(<span class="number">1</span>,<span class="number">115200</span>, <span class="number">16000000</span>);</span><br><span class="line"><span class="comment">//UART编号、波特率、UART时钟频率（频率要和上一行设的一致）</span></span><br><span class="line"></span><br><span class="line">UARTprintf(<span class="string">&quot;Enter Text: \n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> getChar;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	getChar=UARTCharGet(UART1_BASE);</span><br><span class="line">	UARTCharPut(UART1_BASE,getChar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更加进阶的功能-UART中断"><a href="#更加进阶的功能-UART中断" class="headerlink" title="更加进阶的功能 UART中断"></a>更加进阶的功能 UART中断</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureUART</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Enable the GPIO Peripheral used by the UART.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);</span><br><span class="line"></span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_UART1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Configure GPIO Pins for UART mode.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    GPIOPinConfigure(GPIO_PC4_U1RX);</span><br><span class="line">    GPIOPinConfigure(GPIO_PC5_U1TX);</span><br><span class="line">    GPIOPinTypeUART(GPIO_PORTC_BASE, GPIO_PIN_4 | GPIO_PIN_5);</span><br><span class="line"></span><br><span class="line">    UARTClockSourceSet(UART1_BASE, UART_CLOCK_PIOSC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Initialize the UART for console I/O.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    UARTStdioConfig(<span class="number">1</span>, <span class="number">115200</span>, <span class="number">16000000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UARTIntHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//清除中断标志</span></span><br><span class="line">       <span class="keyword">uint32_t</span> ui32Status;</span><br><span class="line">       ui32Status = UARTIntStatus(UART1_BASE, <span class="literal">true</span>);</span><br><span class="line">       UARTIntClear(UART1_BASE, ui32Status);</span><br><span class="line">       <span class="comment">//循环直到接受队列中不存在字符</span></span><br><span class="line">       <span class="keyword">while</span>(UARTCharsAvail(UART1_BASE))<span class="comment">//loop while there are chars</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//串口输出一个char型</span></span><br><span class="line">           UARTCharPutNonBlocking(UART1_BASE,UARTCharGetNonBlocking(UART1_BASE));</span><br><span class="line">           <span class="comment">//闪一下灯</span></span><br><span class="line">           GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, GPIO_PIN_2);</span><br><span class="line">           SysCtlDelay(SysCtlClockGet() /<span class="number">10</span> / <span class="number">3</span>);</span><br><span class="line">           GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, <span class="number">0</span>);</span><br><span class="line">           SysCtlDelay(SysCtlClockGet() / <span class="number">10</span> / <span class="number">3</span>);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">int_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    IntMasterEnable();</span><br><span class="line">    IntEnable(INT_UART1);</span><br><span class="line">    UARTIntEnable(UART1_BASE,UART_INT_RX|UART_INT_RT);</span><br><span class="line">    UARTIntRegister(UART1_BASE,UARTIntHandler);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MAP_FPULazyStackingEnable();</span><br><span class="line">    MAP_SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ |</span><br><span class="line">                       SYSCTL_OSC_MAIN);</span><br><span class="line">    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);</span><br><span class="line">    MAP_GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_2);</span><br><span class="line">    ConfigureUART();</span><br><span class="line">    int_init();</span><br><span class="line">    UARTprintf(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="至高功能-测试FIFO"><a href="#至高功能-测试FIFO" class="headerlink" title="至高功能 测试FIFO"></a>至高功能 测试FIFO</h3><p>代码放在这，有时间再看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置接收中断，当接收FIFO半满（8byte）时触发。利用串口调试助手一个char一个char发送。</span></span><br><span class="line"><span class="comment">//观察到发送8个char后进入中断，FIFO测试成功</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/tm4c123gh6pm.h&quot;</span>				<span class="comment">//Register Definitions</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_memmap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;inc/hw_types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/sysctl.h&quot;</span></span></span><br><span class="line"><span class="comment">//#include &quot;inc/hw_ints.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/interrupt.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/gpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/uart.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;uartstdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;driverlib/pin_map.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> delay_ms(n); SysCtlDelay(n*(SysCtlClockGet()/3000));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UARTIntHandler</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> ui32Status;</span><br><span class="line">	ui32Status = UARTIntStatus(UART1_BASE, <span class="literal">true</span>); <span class="comment">//get interrupt status</span></span><br><span class="line">	UARTIntClear(UART1_BASE, ui32Status); 				<span class="comment">//clear the asserted interrupts</span></span><br><span class="line">	<span class="keyword">while</span>(UARTCharsAvail(UART1_BASE)) 						<span class="comment">//loop while there are chars</span></span><br><span class="line">	&#123;</span><br><span class="line">		UARTCharPutNonBlocking(UART1_BASE, UARTCharGetNonBlocking(UART1_BASE)); <span class="comment">//echo character</span></span><br><span class="line">		GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, GPIO_PIN_2); <span class="comment">//blink LED</span></span><br><span class="line">		delay_ms(<span class="number">1</span>);</span><br><span class="line">		GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_2, <span class="number">0</span>); <span class="comment">//turn off LED</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	SysCtlClockSet(SYSCTL_SYSDIV_4 | SYSCTL_USE_PLL | SYSCTL_OSC_MAIN | SYSCTL_XTAL_16MHZ);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使能外设</span></span><br><span class="line">	SysCtlPeripheralEnable(SYSCTL_PERIPH_UART1);</span><br><span class="line">	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//配置复用功能</span></span><br><span class="line">	GPIOPinConfigure(GPIO_PB0_U1RX);</span><br><span class="line">	GPIOPinConfigure(GPIO_PB1_U1TX);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//分配UART信号</span></span><br><span class="line">	GPIOPinTypeUART(GPIO_PORTB_BASE,GPIO_PIN_0|GPIO_PIN_1);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//LED配置</span></span><br><span class="line">	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF); 				<span class="comment">//enable GPIO port for LED</span></span><br><span class="line">	GPIOPinTypeGPIOOutput(GPIO_PORTF_BASE, GPIO_PIN_2); <span class="comment">//enable pin for LED PF2</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//串口参数设置</span></span><br><span class="line">	UARTClockSourceSet(UART1_BASE, UART_CLOCK_PIOSC);	<span class="comment">//使用16MHz内部高精度振荡器(PIOSC)作为UART模块时钟</span></span><br><span class="line">	UARTStdioConfig(<span class="number">1</span>,<span class="number">115200</span>, <span class="number">16000000</span>);							<span class="comment">//UART编号、波特率、UART时钟频率（频率要和上一行设的一致）</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//FIFO配置，</span></span><br><span class="line">	UARTFIFOLevelSet(UART1_BASE,UART_FIFO_TX4_8,UART_FIFO_RX4_8);	<span class="comment">//FIFO填入半满（8byte）时触发中断</span></span><br><span class="line">	UARTFIFOEnable(UART1_BASE);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//中断使能</span></span><br><span class="line">	IntMasterEnable(); 																			<span class="comment">//enable processor interrupts</span></span><br><span class="line">	IntEnable(INT_UART1); 																	<span class="comment">//enable the UART interrupt</span></span><br><span class="line">	UARTIntEnable(UART1_BASE, UART_INT_RX); 	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注册中断服务函数</span></span><br><span class="line">	UARTIntRegister(UART1_BASE,UARTIntHandler);</span><br><span class="line">	</span><br><span class="line">	UARTprintf(<span class="string">&quot;Enter Text: \n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) <span class="comment">//let interrupt handler do the UART echo function</span></span><br><span class="line">	&#123;	</span><br><span class="line">		;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>进一步进行其他FIFO中断测试，如下：</p>
<ul>
<li><strong>打开FIFO的情况下</strong>，打开<code>UART_INT_OE</code>（FIFO溢出中断），此时<strong>FIFO深度无作用</strong>，FIFO接收17个（FIFO溢出）后进入中断，第17个byte丢失，会输出FIFO中存储的所有16个字符，特别注意FIFO溢出是一个错误引发的中断，在中断服务函数中，<strong>除了用<code>UARTIntClear</code>清除标志，还要写一句<code>HWREG(UART1_BASE+UART_O_ECR)=0;</code>清除错误标志</strong>，否则中断只能进一次。</li>
<li><strong>关闭FIFO的情况下（相当于FIFO深度为1）</strong>，打开<code>UART_INT_OE</code>（FIFO溢出中断），连续收到两个byte溢出，在中断中打印第一个byte；打开<code>UART_INT_RX</code>（FIFO溢出中断），每收到一个byte都会进中断打印</li>
</ul>
<h2 id="部分库函数小结"><a href="#部分库函数小结" class="headerlink" title="部分库函数小结"></a>部分库函数小结</h2><h4 id="（1）void-UARTprintf-const-char-pcString-…"><a href="#（1）void-UARTprintf-const-char-pcString-…" class="headerlink" title="（1）void UARTprintf(const char *pcString, …)"></a>（1）void UARTprintf(const char *pcString, …)</h4><ol>
<li>包含<code>uartstdio.c</code>和<code>uartstdio.h</code>后可用</li>
<li>类似C语言printf()</li>
</ol>
<h4 id="（2）void-UARTCharPut-uint32-t-ui32Base-unsigned-char-ucData"><a href="#（2）void-UARTCharPut-uint32-t-ui32Base-unsigned-char-ucData" class="headerlink" title="（2）void UARTCharPut(uint32_t ui32Base, unsigned char ucData)"></a>（2）void UARTCharPut(uint32_t ui32Base, unsigned char ucData)</h4><ol>
<li>串口输出一个char型</li>
<li>等待FIFO中有数据再发送</li>
</ol>
<h4 id="（3）int32-t-UARTCharGet-uint32-t-ui32Base"><a href="#（3）int32-t-UARTCharGet-uint32-t-ui32Base" class="headerlink" title="（3）int32_t UARTCharGet(uint32_t ui32Base)"></a>（3）int32_t UARTCharGet(uint32_t ui32Base)</h4><ol>
<li>串口接收一个uint32_t型数据</li>
<li>等待FIFO中有数据再接收</li>
</ol>
<h4 id="（4）bool-UARTCharPutNonBlocking-uint32-t-ui32Base-unsigned-char-ucData"><a href="#（4）bool-UARTCharPutNonBlocking-uint32-t-ui32Base-unsigned-char-ucData" class="headerlink" title="（4）bool UARTCharPutNonBlocking(uint32_t ui32Base, unsigned char ucData)"></a>（4）bool UARTCharPutNonBlocking(uint32_t ui32Base, unsigned char ucData)</h4><ol>
<li>串口输出一个char型</li>
<li>若发送时FIFO已满时，直接返回false而不在那循环等待</li>
</ol>
<h4 id="（5）int32-t-UARTCharGetNonBlocking-uint32-t-ui32Base"><a href="#（5）int32-t-UARTCharGetNonBlocking-uint32-t-ui32Base" class="headerlink" title="（5）int32_t UARTCharGetNonBlocking(uint32_t ui32Base)"></a>（5）int32_t UARTCharGetNonBlocking(uint32_t ui32Base)</h4><ol>
<li>串口接收一个uint32_t型数据</li>
<li>如果遇到接收时FIFO为空，直接返回false而不在那循环等待</li>
</ol>
<h4 id="（6）void-UARTFIFOLevelSet-uint32-t-ui32Base-uint32-t-ui32TxLevel-uint32-t-ui32RxLevel"><a href="#（6）void-UARTFIFOLevelSet-uint32-t-ui32Base-uint32-t-ui32TxLevel-uint32-t-ui32RxLevel" class="headerlink" title="（6）void UARTFIFOLevelSet(uint32_t ui32Base, uint32_t ui32TxLevel,uint32_t ui32RxLevel)"></a>（6）void UARTFIFOLevelSet(uint32_t ui32Base, uint32_t ui32TxLevel,uint32_t ui32RxLevel)</h4><ol>
<li>配置输入输出FIFO的深度</li>
</ol>
<h4 id="（7）void-UARTFIFOEnable-uint32-t-ui32Base"><a href="#（7）void-UARTFIFOEnable-uint32-t-ui32Base" class="headerlink" title="（7）void UARTFIFOEnable(uint32_t ui32Base)"></a>（7）void UARTFIFOEnable(uint32_t ui32Base)</h4><ol>
<li>开启某UART的FIFO功能</li>
</ol>
<hr>
<h2 id="UART向上位机发送信息模板"><a href="#UART向上位机发送信息模板" class="headerlink" title="UART向上位机发送信息模板"></a>UART向上位机发送信息模板</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ConfigureUART();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConfigureUART</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);</span><br><span class="line">    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);</span><br><span class="line">    ROM_GPIOPinConfigure(GPIO_PA0_U0RX);</span><br><span class="line">    ROM_GPIOPinConfigure(GPIO_PA1_U0TX);</span><br><span class="line">    ROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);</span><br><span class="line">    UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);</span><br><span class="line">    UARTStdioConfig(<span class="number">0</span>, <span class="number">115200</span>, <span class="number">16000000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/UART/" data-id="cklymn3q20010083dcoruhiwm" data-title="UART" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Timer" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/Timer/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/Timer/">Timer</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>可编程定时器对于驱动定时器输入管脚的外部事件进行计数或计时。</p>
<blockquote>
<p>前置知识</p>
<p>trigger是触发的意思</p>
<p>本单片机提供了8个定时器</p>
<p>有定时器/计数器/RTC…模式</p>
</blockquote>
<p>定时器实质上就是一个加1计数器。它随着计数器的输入脉冲进行自加1，也就是说当每来一个脉冲，计数器就会自动加1,如果当加到计数器为全1时，再输入一个脉冲就使计数器回零，且计数器的溢出使相应的中断标志位置1，向CPU发出就会发出中断请求。</p>
<h5 id="以下内容来自机翻"><a href="#以下内容来自机翻" class="headerlink" title="以下内容来自机翻"></a>以下内容来自机翻</h5><p>定时器API提供了一组用于使用定时器模块的函数。这些函数能配置和控制定时器，修改定时器/计数器的值，并管理定时器的中断处理。</p>
<p>定时器模块可以是两个半宽度的定时器/计数器独立运行或者作为全宽的计时器/Real Time Clock (RTC)运行。</p>
<p>有些定时器提供了16位半宽定时器和32位全宽定时器，而其他定时器则提供了32位半宽定时器和64位全宽定时器。</p>
<p>在此API中，提供两个半宽定时器的定时器模块称为TimerA和TimerB，而提供全宽定时器的定时器模块被称为TimerA。</p>
<p>当配置为全宽或半宽定时器时，可以将定时器设置为单次运行模式。如果配置为单次计时模式，则它在向下计数到零 或者向上计数到 load value 时停止。</p>
<p>如果配置为连续计数模式下，定时器计数到零（向下计数）或 load value（向上计数），然后重新加载和<br>继续计数。</p>
<p>当配置为全宽定时器时，定时器也可配置为RTC运行。在这种模式下，定时器希望由32.768KHz外部时钟驱动。<br>被分割成1秒的时钟刻度。<br>在半宽模式下，定时器也可以配置为事件捕获或为PWM generator。当配置为事件捕获时，定时器作为一个计数器。当配置为事件捕获时，定时器作为计数器。<br>可以配置为计算事件之间的时间或事件本身。事件的类型被计数的事件可以配置为正边、负边或两个边。</p>
<p>当定时器被配置为PWM发生器，用于捕捉事件的输入信号就变成了一个输出信号，而定时器则在该信号上驱动一个边缘对齐的脉冲。<br>定时器模块还提供了控制函数参数的能力，比如输出反转，输出触发，计时器行为等。<br>反转、输出触发器和停顿期间的定时器行为。</p>
<p>还提供了对中断源和事件的控制。中断可以生成以指示事件表示已被捕获，或表示一定数量的事件已被捕获。当计数器下数到零或者上数到特定值时也会产生中断。</p>
<p>在某些部件上，来自多个定时器的counter是可以被同步的。同步了的计数器在PWM和边缘时间捕获模式下非常有用。在PWM模式下，来自多个定时器可以通过具有相同的负载值和同步计数器来实现锁步。（意味着计数器的值总是相同的）。同样，通过使用相同的负载值和同步了的计数器在边缘捕捉模式下，两个输入边缘之间的绝对时间可以很容易地测量。<br>这个驱动包含在driverlib/timer.c中，driverlib/timer.h中包含了API。</p>
<p>The timer API is broken into three groups of functions: those that deal with timer configuration and control, those that deal with timer contents, and those that deal with interrupt handling.</p>
<p>Timer configuration is handled by TimerConfigure(), which performs the high level setup of the timer module; that is, it is used to set up full- or half-width modes, and to select between PWM, capture, and timer operations.   Timer control is performed by TimerEnable(),  TimerDisable(),  TimerCon- trolLevel(),  TimerControlTrigger(),  TimerControlEvent(),  TimerControlStall(),  TimerRTCEnable(), and imerRTCDisable().</p>
<p>Timer content is managed with TimerLoadSet(), TimerLoadGet(), TimerLoadSet64(), TimerLoad- Get64(),<br> TimerPrescaleSet(),  TimerPrescaleGet(),  TimerMatchSet(),  TimerMatchGet(),  Timer- MatchSet64(),  TimerMatchGet64(),  TimerPrescaleMatchSet(),  TimerPrescaleMatchGet(),  Timer- ValueGet(), TimerValueGet64(), and TimerSynchronize().</p>
<p>The interrupt handler for the Timer interrupt is managed with TimerIntRegister() and TimerIntUnreg-<br>ister(). The individual interrupt sources within the timer module are managed with<br>TimerIntEnable(), TimerIntDisable(), TimerIntStatus(), and TimerIntClear().</p>
<p>即这些函数</p>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201211233946109.png" alt="image-20201211233946109"></p>
<h2 id="TI怎样配置计时器？"><a href="#TI怎样配置计时器？" class="headerlink" title="TI怎样配置计时器？"></a>TI怎样配置计时器？</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TimerConfigure(TIMER0_BASE, TIMER_CFG_ONE_SHOT);<span class="comment">//单次计数模式</span></span><br><span class="line">TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC);<span class="comment">//周期性计数模式</span></span><br><span class="line">TimerLoadSet(TIMER0_BASE, <span class="number">2222222</span>- <span class="number">1</span>);<span class="comment">//设定预装栽值</span></span><br><span class="line">IntEnable(INT_TIMER0A);  <span class="comment">//使能TIMER0A</span></span><br><span class="line">TimerIntEnable(TIMER0_BASE, TIMER_TIMA_TIMEOUT); <span class="comment">//TIMEOUT标志位触发中断</span></span><br><span class="line"><span class="comment">//TIMER0A开始计数，当计数值等于TimerLoadSet，触发中断 </span></span><br></pre></td></tr></table></figure>
<p>​    其他资料</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38427678/article/details/94618235">timer笔记</a></p>
<p><a target="_blank" rel="noopener" href="http://home.eeworld.com.cn/my/space-uid-525682-blogid-237550.html">这里是定时器单次计时，周期计时，数捕获，计时捕获模式的例程</a></p>
<p>总结如下</p>
<h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201211234402578.png" alt="image-20201211234402578"></p>
<p>这是前两个函数，与ADC（模拟信号转数字信号）功能有关（坑）</p>
<h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201211234632777.png" alt="image-20201211234632777"></p>
<p>第一个 能用来获取Timer的时钟源</p>
<p>第二个 能设置Timer的时钟源</p>
<p>第三个 能设置Timer模式</p>
<blockquote>
<p>现在介绍一下参数长啥样</p>
<p>全宽模式为TIMER<em>CFG</em>*</p>
<p>半宽模式为TIMER<em>CFG_A</em><em> and TIMER<em>CFG_B</em></em></p>
<p>后面的参数有哪些？</p>
<p>1.SHOT 单次计数</p>
<p>2.SHOT_UP  向上单次计数（看来上一个就是向下计数了。。）</p>
<p>3.PERIODIC 周期计数</p>
<p>4.PERIDIC_UP 向上周期计数</p>
<p>5.RTC 实时时钟模式</p>
<p>还有一些只有在全宽模式才有的参数：SPILT_PAIR 两个半宽计时器？</p>
<p>还有一些只有在半宽模式才有的参数：</p>
<p>1.CAP_COUNT 计数捕捉</p>
<p>2.CAP_COUNT_UP 向上计数捕捉</p>
<p>3.CAP_TIME 沿计数捕捉</p>
<p>4.CAP_TIME_UP 向上计数捕捉</p>
<p>5.PWM PWM输出</p>
<p>还有一些其他action可以引起计数不管了。。</p>
</blockquote>
<p>第四个 能控制事件类型（下面是参数）</p>
<blockquote>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212000342536.png" alt="image-20201212000342536"></p>
</blockquote>
<p>第五个 控制输出水平？？好像是针对PWM的。</p>
<p>第六个 控制stall handling？？</p>
<p>第七个 使能或着使不能ADC触发输出</p>
<p>第八个 控制等待触发句柄</p>
<p>最后一个 使不能Timer</p>
<h1 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h1><p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212123915820.png" alt="image-20201212123915820"></p>
<p>第一个 第二个 DMA事件的设置和获取</p>
<p>第三个 使能Timer</p>
<p>第四个 清除Timer中断源</p>
<blockquote>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212124644391.png" alt="image-20201212124644391"></p>
</blockquote>
<p>第五个 第六个 使能/使不能Timer中断 </p>
<blockquote>
<p>有很多种中断源呢，比如说DMA event match(匹配) timeout(溢出) rtc(实时时钟)等等</p>
</blockquote>
<p>第七个 注册Timer中断</p>
<p>第八个 获取当前的中断状态 这个状态就是在使能Timer中断时设置的状态</p>
<p>第九个 解除注册Timer中断</p>
<p>倒数第四个 倒数第三个 获取Timer的load value</p>
<p>最后两个 设置Timer的load value</p>
<h1 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h1><p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212130358326.png" alt="image-20201212130358326"></p>
<p>第一个 第二个 获取Timer的匹配值</p>
<p>第三个第四个 设置Timer的匹配值</p>
<p>第五个 获得prescale的值 （获取预分频的值）</p>
<blockquote>
<p>分频就是把系统工作频率分频后当做定时器的工作频率！！例如系统时钟为12MHz，12分频后定时器的工作时钟为1MHz</p>
</blockquote>
<p>第六个 设置prescale的值</p>
<p>第七个 第八个 使能/使不能RTC</p>
<p>第九个 定时器同步（再问问？）</p>
<blockquote>
<p>在一些计数器种同步他们的counter</p>
</blockquote>
<p>第十个 定时器更新模式</p>
<blockquote>
<p><img src="C:\Users\smallcannabis\AppData\Roaming\Typora\typora-user-images\image-20201212133616220.png" alt="image-20201212133616220"></p>
</blockquote>
<p>第十一个 第十二个 获取定时器当前的值</p>
<h1 id="这里必须要有这份文档做参考-20-1-pdf"><a href="#这里必须要有这份文档做参考-20-1-pdf" class="headerlink" title="这里必须要有这份文档做参考%20(1).pdf)"></a><a href="file:///C:/Users/smallcannabis/Downloads/TI%20Stellaris%20LM4F%E5%AE%9A%E6%97%B6%E5%99%A8%E6%8C%87%E5%8D%97(Timer">这里必须要有这份文档做参考</a>%20(1).pdf)</h1><p>定时器模式</p>
<p>看如下代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制灯的亮灭</span></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WTimer0BIntHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//注意！一定要清除当前中断标志</span></span><br><span class="line">    TimerIntClear(WTIMER0_BASE, TIMER_TIMB_TIMEOUT);</span><br><span class="line">    t++;</span><br><span class="line">    <span class="keyword">if</span>(t%<span class="number">2</span>)&#123;</span><br><span class="line">        GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3,GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        GPIOPinWrite(GPIO_PORTF_BASE, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Timer_init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SysCtlPeripheralEnable(SYSCTL_PERIPH_WTIMER0);</span><br><span class="line">    <span class="comment">//这里拆分了Wtime0，仅仅使用timer_b</span></span><br><span class="line">    TimerConfigure(WTIMER0_BASE,TIMER_CFG_SPLIT_PAIR|TIMER_CFG_B_PERIODIC);</span><br><span class="line">    <span class="comment">//拆分了的话使用TimerLoadSet 没拆分在后面加上64</span></span><br><span class="line">    <span class="comment">//这里设置为每一秒触发一次中断</span></span><br><span class="line">    TimerLoadSet(WTIMER0_BASE,TIMER_B,<span class="number">1000000</span>);</span><br><span class="line">    <span class="comment">//设置中断处理函数</span></span><br><span class="line">    TimerIntRegister(WTIMER0_BASE,TIMER_B,WTimer0BIntHandler);</span><br><span class="line">    <span class="comment">//接下来是使能中断和使能定时器</span></span><br><span class="line">    IntMasterEnable();</span><br><span class="line">    IntEnable(INT_WTIMER0B);</span><br><span class="line">    TimerIntEnable(WTIMER0_BASE,TIMER_TIMB_TIMEOUT);</span><br><span class="line">    TimerEnable(WTIMER0_BASE,TIMER_B);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/Timer/" data-id="cklymn3q30012083deoclbnsf" data-title="Timer" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-boosterpacks" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/boosterpacks/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/boosterpacks/">BoosterPacks使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="BoosterPacks的使用"><a href="#BoosterPacks的使用" class="headerlink" title="BoosterPacks的使用"></a>BoosterPacks的使用</h1><p>留坑</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/boosterpacks/" data-id="cklymn3q30014083dc55m37jw" data-title="BoosterPacks使用" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-c文件和头文件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/c%E6%96%87%E4%BB%B6%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/c%E6%96%87%E4%BB%B6%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6/">关于怎样写c文件和头文件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="关于怎样写c文件和头文件"><a href="#关于怎样写c文件和头文件" class="headerlink" title="关于怎样写c文件和头文件"></a>关于怎样写c文件和头文件</h1><h2 id="c语言的编译过程"><a href="#c语言的编译过程" class="headerlink" title="c语言的编译过程"></a>c语言的编译过程</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理主要处理</p>
<p>1.源程序的宏定义指令</p>
<p>2.条件编译指令</p>
<p>3.头文件包含指令</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>将源程序转换为汇编代码</p>
<h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>将汇编语言代 码转化成机器语言</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>将各个目标文件中的各段代码进行绝对定位，生成根特定平台相关的可执行文件。（就是生成.exe文件）</p>
<h2 id="那么-h-和-c-文件怎么用呢？"><a href="#那么-h-和-c-文件怎么用呢？" class="headerlink" title="那么.h 和 .c 文件怎么用呢？"></a>那么.h 和 .c 文件怎么用呢？</h2><p>看如下例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;a.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   foo(); </span><br><span class="line"> 　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>现在来看一个大佬的解释：</p>
<blockquote>
<p>从C编译器角度看，.h和.c皆是浮云，就是改名为.txt、.doc也没有大的分别。换句话说，就是.h和.c没啥必然联系。.h中一般放的是同名.c文件中定义的变量、数组、函数的声明，需要让.c外部使用的声明。这个声明有啥用？只是让需要用这些声明的地方方便引用。<u> 因为 #include “xx.h” 这个宏其实际意思就是把当前这一行删掉，把 xx.h 中的内容原封不动的插入在当前行的位置</u>。由于想写这些函数声明的地方非常多（每一个调用 xx.c 中函数的地方，都要在使用前声明一下子），所以用 #include “xx.h” 这个宏就简化了许多行代码——让预处理器自己替换好了。也就是说，xx.h 其实只是让需要写 xx.c 中函数声明的地方调用（可以少写几行字），至于 include 这个 .h 文件是谁，是 .h 还是 .c，还是与这个 .h 同名的 .c，都没有任何必然关系。<br>  这样你可能会说：啊？那我平时只想调用 xx.c 中的某个函数，却 include了 xx.h 文件，岂不是宏替换后出现了很多无用的声明？没错，确实引入了很多垃圾 ，但是它却省了你不少笔墨，并且整个版面也看起来清爽的多。鱼与熊掌不可得兼，就是这个道理。反正多些声明（.h一般只用来放声明，而放不定义，参见拙著“过马路，左右看”）也无害处，又不会影响编译，何乐而不为呢？</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/c%E6%96%87%E4%BB%B6%E5%92%8C%E5%A4%B4%E6%96%87%E4%BB%B6/" data-id="cklymn3q40018083d0bund5ob" data-title="关于怎样写c文件和头文件" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-phripheral-list" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/29/phripheral-list/" class="article-date">
  <time class="dt-published" datetime="2021-01-28T16:00:00.000Z" itemprop="datePublished">2021-01-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/29/phripheral-list/">该单片机外设清单</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="这款单片机的外设清单"><a href="#这款单片机的外设清单" class="headerlink" title="这款单片机的外设清单"></a>这款单片机的外设清单</h1><p>ADC 0 1</p>
<p>CAN 0 1</p>
<p>CCM 0</p>
<p>COMP0 </p>
<p>EEPROM0</p>
<p>EMAC</p>
<p>EPHY</p>
<p>EPI0</p>
<p>GPIO A B C D E F G H J K L M N P Q R S T </p>
<p>HIBERNATE</p>
<p>I2C 0 1 2 3 3 4 5 6 7 8 9</p>
<p>LCD0</p>
<p>ONEWIRE 0</p>
<p>PWM 0 1 </p>
<p>QEI 0 1 </p>
<p>SSI 0 1 2 3</p>
<p>TIMER 0 1 2 3 4 5 6 7</p>
<p>UART 0 1 2 3 4 5 6 7 </p>
<p>UDMA</p>
<p>USB 0 </p>
<p>WDOG 0 1 </p>
<p>WTIMER 0 1 2 3 4 5</p>
<p>共计22种</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/29/phripheral-list/" data-id="cklymn3q6001f083d4x415nl2" data-title="该单片机外设清单" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/midi/" rel="tag">midi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/" rel="tag">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" rel="tag">单片机</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/midi/" style="font-size: 10px;">midi</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/%E5%8D%95%E7%89%87%E6%9C%BA/" style="font-size: 20px;">单片机</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/07/permutation/">generate permutation</a>
          </li>
        
          <li>
            <a href="/2021/03/02/1-Wire_Master/">1-Wire_Master</a>
          </li>
        
          <li>
            <a href="/2021/03/01/ESP8266/">esp8266</a>
          </li>
        
          <li>
            <a href="/2021/03/01/bottom/">bottom</a>
          </li>
        
          <li>
            <a href="/2021/02/28/%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8/">通用定时器</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 smallcracker<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>